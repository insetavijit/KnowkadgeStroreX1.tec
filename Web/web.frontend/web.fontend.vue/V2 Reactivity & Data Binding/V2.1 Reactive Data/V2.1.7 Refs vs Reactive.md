|**Subtopic**|**Focus & Purpose**|**Key Concepts / Details**|**One-Line Recall**|
|---|---|---|---|
|**[[V2.1.7.1 Use Cases Comparison]]**|When to use each|Primitives vs objects, single values vs collections, use case guidance|ref() for primitives, reactive() for objects.|
|**[[V2.1.7.2 API Differences]]**|Syntax comparison|.value access vs direct, unwrapping behavior, API usage patterns|refs need .value, reactive objects don't.|
|**[[V2.1.7.3 Destructuring Behavior]]**|Handle destructuring|ref destructuring loses reactivity, toRefs solution, reactive destructuring|Don't destructure reactive objects without toRefs.|
|**[[V2.1.7.4 Performance Tradeoffs]]**|Understand costs|Overhead differences, tracking granularity, performance considerations|Both have similar performance characteristics.|
|**[[V2.1.7.5 Best Practices]]**|Choose correctly|Team conventions, consistency, readability, pragmatic choices|Choose based on data shape and team style.|
