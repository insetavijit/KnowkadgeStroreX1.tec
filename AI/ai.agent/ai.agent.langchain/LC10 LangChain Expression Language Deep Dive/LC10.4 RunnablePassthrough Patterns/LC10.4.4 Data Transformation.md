| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.4.4.1 Reshaping Data**                  | Structural change                       | Flattening, nesting, renaming keys                                            | Transform the structure of data to fit the next step.           |
| **LC10.4.4.2 Filtering**                       | Reducing data                           | Removing keys, shortening lists                                               | Remove unnecessary data to save tokens.                         |
| **LC10.4.4.3 Formatting**                      | Presentation                            | Dates to strings, objects to Markdown                                         | Format data for prompt ingestion.                               |
| **LC10.4.4.4 The Map Pattern**                 | List transformation                     | Applying transforms to lists via .map()                                       | Transform every item in a list.                                 |
| **LC10.4.4.5 Lambda vs Passthrough**           | Decision                                | When to use explicit Lambda vs implicit Passthrough magic                     | Use Lambda for complex logic; Passthrough for structural edits. |

# Data Transformation: The Adapter Layer

Between your data output and your Prompt input lies the "Adapter Layer". Prompts expect strings; chains produce objects. Transformation bridges the gap.

---

## 1. Reshaping Data (Renaming Keys)

Step A outputs `{"query": "..."}`.
Step B expects `{"question": "..."}`.

**Solution**: Use a Lambda Adapter.

```python
adapter = RunnableLambda(lambda x: {"question": x["query"]})

chain = step_a | adapter | step_b
```

---

## 2. Formatting (Objects to Text)

Prompts consume text. You often need to serialize objects.

```python
def format_docs(docs):
    return "\n---\n".join(d.page_content for d in docs)

rag_chain = (
    {
        "context": retriever | format_docs, # Transform List[Doc] -> str
        "question": RunnablePassthrough()
    }
    | prompt
)
```

The `retriever | format_docs` sub-chain is a pure transformation block.

---

## 3. Filtering (Token Management)

Don't pass huge objects if you only need one field.

```python
# Assume input is a massive User object
def extract_bio(user_obj):
    return user_obj["profile"]["bio"]

# Chain only sees the bio string
chain = RunnableLambda(extract_bio) | prompt | llm
```

This saves context window context by stripping irrelevant metadata.

---

## 4. The Map Pattern (List Transformation)

If you have `List[Dict]` and need `List[str]`.

```python
# Input: [{"name": "A"}, {"name": "B"}]

transform = RunnableLambda(lambda x: x["name"]) # Transforms one
list_transform = transform.map()                # Transforms list

chain = list_transform
# Output: ["A", "B"]
```

---

## Quick Reference

| Task | Tool |
|------|------|
| **Rename Keys** | `Lambda(lambda x: {"new": x["old"]})` |
| **Serialize** | `Lambda(lambda x: str(x))` |
| **Extract** | `Lambda(lambda x: x["field"])` |
| **List Map** | `runnable.map()` |
