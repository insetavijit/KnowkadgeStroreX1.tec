| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.4.3.1 Definition of Side Effects**      | Action at a distance                    | Operations that don't change the return value (Logging, DB writes)            | Side effects act on the world but don't change the data flow.   |
| **LC10.4.3.2 The Passthrough Trick**           | Implementation                          | Using a specific Lambda pattern to run code and return input                  | Run code, then return original input (x).                       |
| **LC10.4.3.3 Logging & Tracing**               | Observability                           | Printing intermediate states                                                  | Use side effects to log data without breaking the chain.        |
| **LC10.4.3.4 Persistence**                     | Storage                                 | Saving inputs to a database or file                                           | Save data to DB asynchronously as it flows through.             |
| **LC10.4.3.5 Async Side Effects**              | Performance                             | Running side effects without blocking the chain                               | Fire-and-forget side effects to keep latency low.               |

# Side Effects: Ghost Actions

A pure function takes X and returns Y.
A function with side effects takes X, returns Y, and *also* writes to a log file, updates a DB, or sends an email.
LCEL encourages purity, but reality demands side effects.

---

## 1. The Passthrough Trick

To create a side effect in LCEL, use a `RunnableLambda` that does something and then returns the original input.

```python
def log_and_continue(x):
    print(f"Log: {x}")
    return x  # <--- CRITICAL: Return input unchanged

chain = step1 | RunnableLambda(log_and_continue) | step2
```

Because it returns `x`, `step2` receives exactly what `step1` outputted. The logging is invisible to the logic.

---

## 2. Persistence (Saving to DB)

Common pattern: "Save the user message to history, then generate answer."

```python
def save_message(x):
    db.save(x["user_id"], x["message"])
    return x

chain = (
    RunnableLambda(save_message) 
    | model 
    | parser
)
```

Usage with `.assign()` ensures the DB logic sits neatly in the flow.

---

## 3. Async Side Effects (Non-Blocking)

If you are saving to a slow DB, don't block the user.

```python
async def save_async(x):
    # Fire and forget (or await if you need confirmation)
    await db.save_async(x)
    return x
```

For true "fire-and-forget" (background tasks), you might need to use `asyncio.create_task()` inside the lambda, so the chain proceeds immediately.

---

## 4. Pure Passthrough for Hooks

You can also use `RunnablePassthrough` constructor with specific hooks in newer LC versions, but the Lambda pattern is the most universal and robust way to implement side effects.

---

## Quick Reference

| Pattern | Code |
|---------|------|
| **Sync Log** | `def log(x): print(x); return x` |
| **Async Log** | `async def log(x): await store(x); return x` |
| **Rule** | **ALWAYS return x** effectively |
