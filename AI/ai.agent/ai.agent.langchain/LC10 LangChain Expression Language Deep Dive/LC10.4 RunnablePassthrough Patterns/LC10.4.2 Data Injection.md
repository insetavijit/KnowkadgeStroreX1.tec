| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.4.2.1 Injection Concept**               | Adding, not changing                    | Augmenting the input dictionary with new keys                                 | Injection adds new data while keeping the old data.             |
| **LC10.4.2.2 Computed Fields**                 | Dynamic values                          | Calculating values based on input and adding them                             | Compute new values derived from the input.                      |
| **LC10.4.2.3 Constant Injection**              | Fixed values                            | Injecting config, environment variables, or constants                         | Inject static constants into the data stream.                   |
| **LC10.4.2.4 External Data**                   | Fetching                                | Injecting DB results or API responses                                         | Fetch external data and merge it into the input.                |
| **LC10.4.2.5 The .assign() Shortcut**          | Syntax                                  | The static method that simplifies injection                                   | .assign() is the clean syntax for data injection.               |

# Data Injection: The Enrichment Pattern

"Transformation" (Map) changes data. "Injection" (Assign) adds to it.
In complex chains, you rarely want to *replace* your state; you want to *enrich* it.

---

## 1. The Injection Concept

Imagine your data is a snowball rolling down a hill. It picks up more snow (data) as it goes.

*   Start: `{"topic": "AI"}`
*   Step 1 (Inject Date): `{"topic": "AI", "date": "2023-10-01"}`
*   Step 2 (Inject User): `{"topic": "AI", "date": "...", "user": "Alice"}`

This preserves context.

---

## 2. The .assign() Shortcut

The clean way to do this is `RunnablePassthrough.assign()`.

```python
from langchain_core.runnables import RunnablePassthrough

# Assume Input: {"num": 1}

chain = RunnablePassthrough.assign(
    mult=lambda x: x["num"] * 10
)

# Output: {"num": 1, "mult": 10}
```

It runs the function, takes the result, and adds it to the input dictionary under the key `mult`.

---

## 3. Computed Fields vs Constant Injection

### Computed (Dynamic)
Value depends on input.

```python
RunnablePassthrough.assign(length=lambda x: len(x["text"]))
```

### Constant (Static)
Use a Lambda that ignores input, or just a raw value (if supported, though usually requires a Runnable).

```python
RunnablePassthrough.assign(version=lambda _: "v1.0")
```

---

## 4. External Data

Use this to fetch context without losing the query.

```python
rag_chain = RunnablePassthrough.assign(
    context=retriever  # Input 'x' goes to retriever; Output -> 'context'
)
# Input: {"question": "Best pizza?"}
# Output: {"question": "Best pizza?", "context": [Doc1, Doc2]}
```

This is superior to `RunnableParallel` when you just want to "add one thing" to the existing stream.

---

## Quick Reference

| Method | Syntax | Usage |
|--------|--------|-------|
| **Generic** | `Parallel({"existing": Passthrough(), "new": ...})` | Verbose, explicit |
| **Assign** | `Passthrough.assign(new=...)` | Clean, additive |
| **Benefit** | **State Management**: detailed context tracking |
