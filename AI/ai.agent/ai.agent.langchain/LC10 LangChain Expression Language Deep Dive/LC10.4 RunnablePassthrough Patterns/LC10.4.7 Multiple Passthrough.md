| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.4.7.1 Parallel Inputs**                 | Multicasting                            | Sending same input to N parallel consumers                                    | Pass input to N places at once.                                 |
| **LC10.4.7.2 Complex Merging**                 | Recombining                             | Merging multiple passthrough streams                                          | Recombine forked streams intelligently.                         |
| **LC10.4.7.3 The "Broadcaster" Topology**      | Architecture                            | One producer, many consumers (Pub/Sub style in chains)                        | Broadcast single signal to multiple listeners.                  |
| **LC10.4.7.4 Race Conditions?**                | Thread Safety                           | Runnables are immutable/stateless; parallel passthrough is safe               | Parallel passthrough is thread-safe by default.                 |
| **LC10.4.7.5 Redundant Execution Consideration**| Performance                            | Ensuring upstream isn't re-run for each branch (caching)                      | Be careful not to re-calculate shared parents.                  |

# Multiple Passthrough: The Broadcaster

What if you need to send the data to 5 places at once? Or fork the stream, process one part, and keep the other raw?

---

## 1. Parallel Inputs (The Star Topology)

```python
chain = RunnableParallel({
    "raw": RunnablePassthrough(),
    "upper": RunnableLambda(lambda x: x.upper()),
    "len": RunnableLambda(lambda x: len(x)),
    "json": RunnableLambda(lambda x: json.dumps(x))
})
```

The input is broadcast to all 4 checks. This is excellent for **validation suites** or **multi-faceted analysis**.

---

## 2. Redundant Execution (Warning)

Be careful with this pattern:

```python
# BAD
heavy_step = ...
chain = RunnableParallel({
    "a": heavy_step | step_a,
    "b": heavy_step | step_b
})
```

`heavy_step` runs TWICE here.

**Fix**: Run heavy step *before* the split.

```python
# GOOD
chain = (
    heavy_step 
    | RunnableParallel({
        "a": step_a,
        "b": step_b
    })
)
```

Now `heavy_step` runs once, and its *result* is passed through to A and B.

---

## Quick Reference

| Concept | Tip |
|---------|-----|
| **Broadcasting** | Easy with `RunnableParallel` |
| **Safety** | Perfectly thread-safe (Runnables are stateless) |
| **Efficiency** | Compute shared ancestors *before* the split point |
