| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.4.8.1 The "RAG Tuple"**                 | Best Practice                           | (context, question) -> prompt                                                 | The standard RAG input pattern.                                 |
| **LC10.4.8.2 The "Diff" Pattern**              | Comparison                              | {"before": Pass, "after": Chain} -> Compare                                   | Keep input and output to compare them.                          |
| **LC10.4.8.3 The "Metadata Attachment"**       | Enrichment                              | Attaching session_id, user_id, timestamps via passthrough                     | Attach metadata seamlessly.                                     |
| **LC10.4.8.4 Anti-Pattern: Over-assign**       | Code Smell                              | .assign(a=..., b=..., c=..., d=...) creating giant dicts                      | Don't build "God Objects" with 50 keys.                         |
| **LC10.4.8.5 Anti-Pattern: Hidden State**      | Code Smell                              | Relying on keys that were assigned 10 steps ago without checking              | Be explicit about what keys are required.                       |

# Passthrough Patterns: The Best Practices

A summary of the "Design Patterns" specifically for Passthrough.

---

## 1. The "Diff" Pattern (Evaluations)

How do you check if your summarizer is working?

```python
eval_chain = (
    RunnablePassthrough.assign(
        summary=summarizer_chain
    )
    | RunnableLambda(lambda x: length(x["summary"]) < length(x["text"]))
)
```

You keep the original `text` so you can compare it to `summary`.

---

## 2. The "Metadata Attachment" (Tracing)

In production, you often need to carry a `trace_id` or `user_id` deep into the system.

Instead of adding it to every function signature `func(x, user_id)`, just inject it at the top and let `.assign()` carry it.

```python
# It just flows through "unused" until the final logging step needs it
chain = (
    RunnablePassthrough.assign(user_id=...)
    | step1
    | step2
    | step3
    | log_step # Uses user_id
)
```

---

## 3. Anti-Patterns

### Logic in Passthrough
**Bad**: `RunnablePassthrough.assign(x=lambda y: complex_logic(y))` where `complex_logic` is 50 lines.
**Fix**: Make `complex_logic` a standalone Runnable or Function, then use it. Keep the `.assign` line clean.

### The "God Object"
Accumulating 20 keys in the dictionary "just in case".
**Fix**: `RunnablePick` or explicit selection to drop keys you no longer need.

---

## Quick Reference

| Pattern | Usage |
|---------|-------|
| **Diff** | Compare Input vs Output |
| **Metadata** | Carry tag-along data (IDs) |
| **God Object** | Avoid keeping too much data |
