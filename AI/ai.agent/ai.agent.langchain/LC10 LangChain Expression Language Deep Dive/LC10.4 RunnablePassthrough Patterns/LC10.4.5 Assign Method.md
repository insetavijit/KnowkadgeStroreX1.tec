| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.4.5.1 Syntax & Behavior**               | How .assign() works                     | Merges new keys into input dict; creates shallow copy                         | .assign() adds keys to the dictionary flowing through.          |
| **LC10.4.5.2 Parallel Execution**              | Performance                             | Multiple assignments run in parallel (RunnableParallel under hood)            | Multiple keys in one .assign() run concurrently.                |
| **LC10.4.5.3 Overwriting Keys**                | Mutation                                | What happens if key exists (it gets replaced)                                 | Assigning to an existing key overwrites it.                     |
| **LC10.4.5.4 Sequential Assigns**              | Dependency management                   | Chaining assigns when one depends on another                                  | Chain .assigns() if step B needs step A's output.               |
| **LC10.4.5.5 The "Context Accumulator"**       | Pattern                                 | Building up a "state object" step by step                                     | Use assign to build a rich context object progressively.        |

# The Assign Method: LCEL's State Manager

`RunnablePassthrough.assign()` is arguably the most used method in advanced chains. It keeps your code flat and readable while building up state.

---

## 1. Syntax and Behavior

It mimics Python's `dict.update()` but functionally (returns a new dict).

```python
# Input: {"a": 1}
chain = RunnablePassthrough.assign(b=lambda x: x["a"] + 1)
# Output: {"a": 1, "b": 2}
```

It takes the input `x`, runs the lambda/chain for `b`, and returns `x + {b}`.

---

## 2. Parallel Execution

If you assign multiple keys, they run in parallel.

```python
chain = RunnablePassthrough.assign(
    b=step_b,  # Takes 1s
    c=step_c   # Takes 1s
)
# Total time: 1s (Parallel)
```

This is shorthand for:
```python
RunnableParallel({
    **{k: RunnablePassthrough() for k in input_keys}, # Pass everything
    "b": step_b,
    "c": step_c
})
```

---

## 3. Sequential Assigns (Dependencies)

If `c` depends on `b`, you must chain them.

```python
chain = (
    RunnablePassthrough.assign(b=step_b) # Adds 'b'
    | RunnablePassthrough.assign(c=lambda x: x["b"] * 2) # Uses 'b' to make 'c'
)
```

You cannot do `assign(b=..., c=...)` if `c` needs `b` because they run in parallel on the *original* input.

---

## 4. The Context Accumulator

This is the standard pattern for RAG and Agents.

```python
chain = (
    RunnablePassthrough.assign(history=get_history)   # Step 1: Add history
    | RunnablePassthrough.assign(docs=retriever)      # Step 2: Add docs
    | RunnablePassthrough.assign(plan=planner)        # Step 3: Add plan
    | prompt                                          # Uses all of them
    | model
)
```

This "waterfall" of context makes the data flow obvious and debuggable.

---

## Quick Reference

| Feature | Details |
|---------|---------|
| **Return Value** | Original Input + New Keys |
| **Concurrency** | Parallel within a single `.assign()` call |
| **Dependencies** | Must use separate `.assign()` calls |
| **Usage** | Primary tool for RAG context gathering |
