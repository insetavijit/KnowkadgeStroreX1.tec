| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.6.2.1 The Chunk Interface**             | Data Structure                          | AIMessageChunk, StringChunk, additive properties (+)                          | Chunks are additive fragments of the final object.              |
| **LC10.6.2.2 Accumulation Logic**              | Reassembly                              | How chunks sum up to a message (chunk1 + chunk2 = chunk12)                    | You can sum chunks to rebuild the message.                      |
| **LC10.6.2.3 Manual chunking**                 | For custom runnables                    | Writing generators to yield chunks in RunnableLambdas                         | Yield partial results to support streaming in custom code.      |
| **LC10.6.2.4 JSON Streaming**                  | Parsing on the fly                      | JsonOutputParser streaming partial JSON objects                               | Stream partial JSON structures for responsive UI.               |
| **LC10.6.2.5 Buffer Handling**                 | UI implementation                       | Updating the UI buffer as chunks arrive                                       | Append chunks to the UI state immediately.                      |

# Chunk Streaming: The Output Flow

`astream()` is simpler than `astream_events`. It only gives you the **final output** of the chain, piece by piece.

---

## 1. The Chunk Interface

Chunks are special. They know how to add themselves.

```python
chunk1 = AIMessageChunk(content="Hello")
chunk2 = AIMessageChunk(content=" World")

full = chunk1 + chunk2
# full is AIMessageChunk(content="Hello World")
```

This aggregation logic is what allows `StrOutputParser` to collect the stream into a final string.

---

## 2. Manual Chunking (Custom Generators)

If you write a `RunnableLambda`, you can support streaming by writing a generator.

```python
def my_streamer(x):
    # This chain supports .stream()!
    yield "Start"
    yield "..."
    yield "End"

chain = RunnableLambda(my_streamer)

for chunk in chain.stream("go"):
    print(chunk)
```

If you just `return "Start...End"`, the `stream()` method will just yield that one string as a single chunk.

---

## 3. JSON Streaming (Partial Parsing)

Streaming JSON is tricky because partial JSON (`{"key": "val`) is invalid syntax.
`JsonOutputParser` handles this!

```python
parser = JsonOutputParser()

# Model outputs: "{", "\"name\":", "\"Alice\"" ...
# Parser yields: {}, {"name": ""}, {"name": "Alice"}
```

It yields the **accumulated partial object** (or creates a diff) so the UI can render "live" forms.

---

## 4. UI Buffer Implementation

On the frontend (React/Python):

1.  Initialize `buffer = ""`
2.  Loop over stream.
3.  `buffer += chunk`
4.  Render `buffer`

This creates the "Typewriter Effect".

---

## Quick Reference

| Class | Usage |
|-------|-------|
| **AIMessageChunk** | Partial LLM response |
| **StringChunk** | Partial string output |
| **Protocol** | `__add__` must be implemented |
| **Generator** | Use `yield` in lambdas to support this |
