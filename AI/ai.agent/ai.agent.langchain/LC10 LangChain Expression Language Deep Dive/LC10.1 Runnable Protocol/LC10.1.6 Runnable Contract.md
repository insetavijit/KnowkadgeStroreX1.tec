| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.1.6.1 Method Consistency**              | Define behavioral expectations          | invoke/batch/stream equivalence, deterministic results                        | All methods must produce semantically equivalent results.       |
| **LC10.1.6.2 Idempotency Expectations**        | Understand repeatability                | Same input → same output, stateless execution                                 | Runnables should be stateless and idempotent.                   |
| **LC10.1.6.3 Error Propagation Rules**         | Define failure behavior                 | Exception types, error context, chain failure                                 | Errors propagate up the chain unless explicitly handled.        |
| **LC10.1.6.4 Side Effect Guidelines**          | Manage external interactions            | Logging, metrics, database writes, idempotent side effects                    | Minimize side effects; when needed, make them idempotent.       |
| **LC10.1.6.5 Composition Guarantees**          | Ensure pipeline reliability             | Input-output matching, chain integrity, type compatibility                    | Composed Runnables inherit the contract of their components.    |

# The Runnable Contract: Behavioral Guarantees

The Runnable interface isn't just about method signatures—it's a **behavioral contract**. When you implement or use a Runnable, you're agreeing to a set of guarantees that make composition reliable and debugging predictable.

---

## 1. Method Consistency: Same Result, Different Delivery

The fundamental promise: `invoke()`, `batch()`, and `stream()` produce **semantically equivalent results**.

```
┌─────────────────────────────────────────────────┐
│              Method Equivalence                 │
├─────────────────────────────────────────────────┤
│  invoke(x)      →  result                       │
│  batch([x])[0]  →  result (same as invoke)      │
│  "".join(stream(x)) →  result (same content)    │
└─────────────────────────────────────────────────┘
```

```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(temperature=0)  # Deterministic for demo

# All three produce equivalent content
result_invoke = llm.invoke("Say hello")
result_batch = llm.batch(["Say hello"])[0]
result_stream = "".join(chunk.content for chunk in llm.stream("Say hello"))

# result_invoke.content ≈ result_batch.content ≈ result_stream
```

**Why This Matters**: You can switch between methods based on use case (real-time UI vs batch processing) without changing your logic.

---

## 2. Idempotency: Stateless Execution

Runnables should behave like **pure functions**: same input, same output (modulo LLM stochasticity).

```python
# ✅ Good: Stateless Runnable
def clean_text(input: str) -> str:
    return input.strip().lower()

# ❌ Bad: Stateful Runnable (avoid this)
class CounterRunnable:
    def __init__(self):
        self.count = 0
    
    def invoke(self, input: str) -> str:
        self.count += 1  # Side effect!
        return f"{self.count}: {input}"
```

### Why Statelessness Matters

*   **Batch Processing**: Items can be processed in any order
*   **Retries**: Failed requests can be safely retried
*   **Caching**: Results can be cached and reused
*   **Parallelism**: No race conditions between concurrent executions

---

## 3. Error Propagation: Fail-Fast by Default

When a Runnable fails, the exception bubbles up the chain immediately.

```python
chain = step1 | step2 | step3

try:
    result = chain.invoke(input)
except ValueError as e:
    # Exception from any step surfaces here
    print(f"Chain failed: {e}")
```

### Error Context Preservation

Exceptions should include context about where they occurred:

```python
from langchain_core.runnables import RunnableLambda

def risky_operation(x):
    if not x:
        raise ValueError("Input cannot be empty")
    return x.upper()

runnable = RunnableLambda(risky_operation)

try:
    runnable.invoke("")
except ValueError as e:
    # Error traces back to the specific Runnable
    print(e)  # "Input cannot be empty"
```

### Contract Rule

> **Errors must propagate unless explicitly suppressed.**
> Use `with_fallbacks()` or `try/except` for recovery—never silently swallow errors.

---

## 4. Side Effect Guidelines

Runnables should minimize side effects, but when necessary, follow these rules:

```
┌─────────────────────────────────────────────────┐
│              Side Effect Spectrum               │
├─────────────────────────────────────────────────┤
│  Pure (best)      →  No side effects            │
│  Observable       →  Logging, metrics           │
│  Idempotent       →  DB upserts, cache writes   │
│  Destructive      →  Deletes, mutations (avoid) │
└─────────────────────────────────────────────────┘
```

### Acceptable Side Effects

```python
import logging

def process_with_logging(input: str) -> str:
    logging.info(f"Processing: {input[:50]}...")  # Observable, safe
    result = input.upper()
    logging.info(f"Completed processing")
    return result
```

### Dangerous Side Effects (Avoid in Runnables)

```python
# ❌ Avoid: Non-idempotent database operations
def bad_runnable(input: str) -> str:
    db.execute("INSERT INTO logs (msg) VALUES (?)", input)  # Duplicates on retry!
    return process(input)

# ✅ Better: Use idempotent operations
def safe_runnable(input: str) -> str:
    db.execute("INSERT OR REPLACE INTO logs (id, msg) VALUES (?, ?)", 
               hash(input), input)  # Idempotent
    return process(input)
```

---

## 5. Composition Guarantees

When Runnables are composed with `|`, the chain inherits guarantees from its components.

### Type Compatibility Rule

> OutputType of step N must match InputType of step N+1.

```python
# ✅ Types align: dict → PromptValue → AIMessage → str
chain = prompt | llm | parser

# ❌ Types mismatch: parser outputs str, llm expects PromptValue
broken_chain = parser | llm  # Runtime error
```

### Failure Propagation Rule

> Chain fails if ANY component fails (unless fallbacks are configured).

### Streaming Propagation Rule

> Chain streams if the FINAL component supports streaming.

```python
# Streams (StrOutputParser supports streaming)
chain1 = prompt | llm | StrOutputParser()

# Does NOT stream (PydanticOutputParser buffers)
chain2 = prompt | llm | PydanticOutputParser(pydantic_object=MyModel)
```

---

## 6. Verification: Testing Contract Compliance

When building custom Runnables, verify contract compliance:

```python
def test_runnable_contract(runnable, test_input):
    """Verify a Runnable follows the contract."""
    
    # 1. Method consistency
    invoke_result = runnable.invoke(test_input)
    batch_result = runnable.batch([test_input])[0]
    assert invoke_result == batch_result, "invoke/batch mismatch"
    
    # 2. Idempotency
    result1 = runnable.invoke(test_input)
    result2 = runnable.invoke(test_input)
    assert result1 == result2, "Not idempotent"
    
    # 3. Error propagation (if applicable)
    try:
        runnable.invoke(invalid_input)
    except Exception as e:
        assert e is not None, "Error should propagate"
    
    print("✅ Contract verified")
```

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **Method Consistency** | invoke, batch, stream produce equivalent results |
| **Idempotency** | Same input → same output, no hidden state |
| **Error Propagation** | Exceptions bubble up unless explicitly handled |
| **Side Effects** | Minimize; when needed, make idempotent |
| **Type Compatibility** | OutputType[N] must match InputType[N+1] |
| **Chain Guarantees** | Inherited from components; fails if any fails |
| **Benefit** | **Reliability**: Predictable behavior enables safe composition |
