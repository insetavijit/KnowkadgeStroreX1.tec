| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.7.5.1 Adding Tags**                     | Syntax                                  | .with_config(tags=[...]) vs constructor tags=[]                               | Add tags to label components for easy filtering.                |
| **LC10.7.5.2 Tag Propagation**                 | Inheritance                             | Children do NOT inherit tags automatically by default in all cases            | Tags label the specific node, they don't always cascade.        |
| **LC10.7.5.3 Filtering Traces**                | Usage                                   | Filtering LangSmith runs by "staging", "prod", "variant-A"                    | Use tags to search and filter traces in LangSmith.              |
| **LC10.7.5.4 Semantic Tagging**                | Strategy                                | Tagging "retrieval", "generation", "guardrail" for analytics                  | Tag steps by their semantic role (e.g., 'retrieval').           |
| **LC10.7.5.5 Dynamic Tagging**                 | Runtime                                 | Adding tags via config at invoke time                                         | Inject tags at runtime to label specific execution runs.        |

# Tags: Labeling the Graph

A complex chain has 50 steps. Which ones are "Retrievers"? Which ones are "LLMs"?
Tags allow you to categorize steps.

---

## 1. Adding Tags

Static tagging (Code time).

```python
chain = (
    step1.with_config(tags=["preprocessing"])
    | step2.with_config(tags=["generation"])
)
```

Now in LangSmith, you can filter: `has_tag("generation")`.

---

## 2. Dynamic Tagging (Runtime)

Labeling a specific *run*.

```python
chain.invoke(input, config={"tags": ["user-123", "experiment-A"]})
```

These tags apply to the **Root Run** and often propagate down to children (depending on implementation specifics of runnables).

---

## 3. Semantic Tagging Strategy

Don't just tag "step1". Use a taxonomy.

*   `db`: Interact with Database.
*   `llm`: Call Model.
*   `guardrail`: Safety check.
*   `legacy`: Old code to be refactored.

This allows you to answer questions like: "How often do our Guardrails trigger?" -> Filter by `tags=["guardrail"]` and status Error.

---

## Quick Reference

| Method | Syntax |
|--------|--------|
| **Static** | `.with_config(tags=["A"])` |
| **Dynamic** | `invoke(x, config={"tags": ["A"]})` |
| **Purpose** | Filtering & Analytics |
