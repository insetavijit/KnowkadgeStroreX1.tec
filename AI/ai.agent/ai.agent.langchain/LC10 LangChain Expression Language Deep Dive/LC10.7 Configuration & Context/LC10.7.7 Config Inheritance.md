| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.7.7.1 Top-Down Flow**                   | Mechanism                               | Config passed to parent flows to children                                     | Config flows from parent to children automatically.             |
| **LC10.7.7.2 Merge Strategy**                  | Conflict resolution                     | Invoke config vs .with_config() vs Default                                    | Innermost / Explicit config usually wins.                       |
| **LC10.7.7.3 Blocking Inheritance**            | Isolation                               | How to stop config from affecting a sub-chain (rare)                          | Inheritance is usually desirable; blocking is manual.           |
| **LC10.7.7.4 Callback Inheritance**            | Tracing                                 | Callbacks flow down; allowing one handler to watch whole chain                | Callbacks attached at the top watch the whole tree.             |
| **LC10.7.7.5 Configurable Field Scope**        | Namespace                               | Ensuring IDs don't collide in large composed chains                           | Use unique IDs for configurable fields to avoid collisions.     |

# Config Inheritance: The Cascade

When you call `parent.invoke(config=C)`, `child` receives `C`.
When `child` calls `grandchild`, `grandchild` receives `C`.

---

## 1. Merge Strategy

What if Parent says `tags=["A"]` and Child says `.with_config(tags=["B"])`?

Usually, they **merge** (for lists) or **overwrite** (for dict keys).
*   Tags: `["A", "B"]` (Union)
*   Metadata: `{"a": 1}` + `{"a": 2}` -> `{"a": 2}` (Child overrides).

---

## 2. Callback Inheritance

This is why `LangfuseCallbackHandler` works.

```python
handler = LangfuseCallbackHandler()
chain.invoke(..., config={"callbacks": [handler]})
```

The handler is passed to Step 1, Step 2, Sub-step 2.1... everyone reports to the same handler.

---

## 3. Configurable Field Scope (Collisions)

If you have two `ChatOpenAI` models in a chain, and both define:
`ConfigurableField(id="llm_temp")`

Setting `config={"configurable": {"llm_temp": 0.5}}` changes **BOTH**.

**Fix**: specific IDs.
*   `id="planner_temp"`
*   `id="writer_temp"`

```python
params = {
    "configurable": {
        "planner_temp": 0.1,
        "writer_temp": 0.9
    }
}
```

---

## Quick Reference

| Type | Behavior |
|------|----------|
| **Tags** | Union (Merge) |
| **Metadata** | Update (Overwrite) |
| **Callbacks** | Union (Append) |
| **Configurable**| Update (Overwrite) |
