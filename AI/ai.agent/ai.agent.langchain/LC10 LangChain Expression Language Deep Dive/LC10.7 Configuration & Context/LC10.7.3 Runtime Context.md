| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.7.3.1 Local vs Global Context**         | Concept                                 | Input is Local; Config is Global                                              | Data flows link-to-link; Config flows top-to-bottom.            |
| **LC10.7.3.2 Accessing Context in Lambdas**    | Mechanics                               | def func(x, config): ...                                                      | Access global config in your lambdas via the second arg.        |
| **LC10.7.3.3 The Contextvar (Hidden)**         | Internal                                | How LangChain uses Python contextvars to pass config implicitly               | LCEL uses contextvars to propagate config behind the scenes.    |
| **LC10.7.3.4 Setting Context Mid-Chain**       | Pattern                                 | .with_config() to attach context to a sub-chain                               | Use .with_config() to inject context into specific steps.       |
| **LC10.7.3.5 Isolation**                       | Scope                                   | Context does not leak *up* or *sideways*, only *down*                         | Context flows strictly downwards to children.                   |

# Runtime Context: The Bloodstream

If Input/Output is the "Nervous System" (Signals), then Configuration is the "Circulatory System" (Blood). It touches every cell (Runnable) but isn't always visible.

---

## 1. Local vs Global

*   **Local**: `x` (Input). Only seen by the current step. Changed at every step.
*   **Global**: `config`. Seen by *all* steps. Preserved (mostly) down the tree.

---

## 2. Accessing in Lambdas

Standard way to "drink from the stream".

```python
def log_user(x, config):
    user_id = config.get("metadata", {}).get("user_id")
    print(f"User {user_id} is here.")
    return x

chain = RunnableLambda(log_user)
chain.invoke(..., config={"metadata": {"user_id": "123"}})
```

---

## 3. Setting Context Mid-Chain (.with_config)

You can hardcode context for a specific branch.

```python
# This step ALWAYS runs with tag "special"
step_special = step.with_config(tags=["special"])

chain = step_normal | step_special
```

When you inspect the trace, `step_special` will have the tag, but `step_normal` will not.

---

## 4. ContextVars (The Magic)

How does `step ` know about the config you passed to `chain.invoke`? You didn't pass it explicitly.

LangChain uses `contextvars`. When `invoke` starts, it sets a global (thread-local) variable. All children look at this variable.

**Note**: This is why `asyncio` context propagation is tricky. LCEL handles copy_context for you, but if you spawn raw threads manually inside a lambda, you might break the context link.

---

## Quick Reference

| Concept | Rule |
|---------|------|
| **Flow** | High -> Low (Downstream) |
| **Access** | `config` arg in Lambdas |
| **Inject** | `.with_config()` |
| **Scope** | Thread-local / Task-local |
