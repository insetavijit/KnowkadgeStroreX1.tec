| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.7.2.1 The configurable_fields Method**  | Interface                               | Exposing parameters (temperature, model name) for runtime adjustment          | Make chain attributes changeable at runtime.                    |
| **LC10.7.2.2 The configurable_alternatives**   | Branching                               | Swapping entire steps (GPT-4 vs Claud) at runtime                             | Swap entire components based on config.                         |
| **LC10.7.2.3 ConfigurableField Spec**          | Definition                              | Defining ID, name, and description for valid options                          | Define fields with IDs to address them in config.               |
| **LC10.7.2.4 "User-Per-Request" Models**       | Use Case                                | Allowing Users to pick their model per query                                  | Let users choose their model via API parameters.                |
| **LC10.7.2.5 The "configurable" Key**          | Usage                                   | Passing actual values via config={'configurable': {'k': 'v'}}                 | Pass dynamic values in the 'configurable' dict.                 |

# Configurable Chains: Runtime Flexibility

Why build 10 chains (one for GPT-3, one for GPT-4, one for high temp...) when you can build **One Chain** that changes behavior based on request config?

---

## 1. configurable_fields (Parameters)

Change attributes of a specific Runnable.

```python
model = ChatOpenAI(temperature=0).configurable_fields(
    temperature=ConfigurableField(
        id="llm_temp", 
        name="LLM Temperature", 
        description="The creativity of the model"
    )
)

# Run with default (0)
model.invoke("Hi")

# Run with override (0.9)
model.invoke("Hi", config={"configurable": {"llm_temp": 0.9}})
```

---

## 2. configurable_alternatives (Swapping)

Swap the whole object.

```python
gpt3 = ChatOpenAI(model="gpt-3.5-turbo")
gpt4 = ChatOpenAI(model="gpt-4")
anthropic = ChatAnthropic(model="claude-2")

model = gpt3.configurable_alternatives(
    ConfigurableField(id="llm"), 
    default_key="gpt3",
    gpt4=gpt4,
    claude=anthropic
)

# Usage
model.invoke("Hi", config={"configurable": {"llm": "gpt4"}})
```

---

## 3. The "configurable" dictionary

Understand the namespace.

`config={"configurable": {"key": "value"}}`

This is a flat dictionary. Keys must be unique across the whole chain. This is why `id="llm_temp"` is usedâ€”to give a global address to a local parameter.

---

## 4. User-Per-Request Pattern

Great for A/B testing or Tiers.

```python
# API Endpoint
def chat(msg, model_tier: str):
    config = {"configurable": {"model": model_tier}}
    return chain.invoke(msg, config=config)
```

Free users get "gpt3", Pro users get "gpt4".

---

## Quick Reference

| Method | Use Case |
|--------|----------|
| **configurable_fields** | Change primitive values (int, float, str) |
| **configurable_alternatives** | Swap Classes/Runnables |
| **Key** | Must match the `id` defined in ConfigurableField |
