| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.7.1.1 The Config Dict**                 | Schema                                  | run_name, tags, metadata, callbacks, configurable, recursion_limit            | RunnableConfig is a standard TypedDict for execution options.   |
| **LC10.7.1.2 Passing Config**                  | Usage                                   | chain.invoke(x, config=...)                                                   | Pass config as the 2nd argument to invoke/stream.               |
| **LC10.7.1.3 Thread Pools (max_concurrency)**  | Performance                             | Controlling thread pool size for batch operations                             | Use max_concurrency to limit parallel execution.                |
| **LC10.7.1.4 Recursion Limit**                 | Safety                                  | Preventing infinite loops in cyclical graphs (Agents)                         | Set recursion_limit to stop runaway agents.                     |
| **LC10.7.1.5 Config Propagation**              | Auto-wiring                             | How config flows automatically down the chain tree                            | Config flows down the chain automatically.                      |

# RunnableConfig: The Control Panel

When you run a chain, you pass two things:
1.  **Input**: The data (What to process).
2.  **Config**: The settings (How to process it).

`RunnableConfig` is the universal settings object for LCEL.

---

## 1. The Config Dict

It is a simple `TypedDict`.

```python
class RunnableConfig(TypedDict):
    run_name: str           # Name in Traces
    tags: List[str]         # Tags for filtering
    metadata: Dict[str, Any]# User data (User ID)
    callbacks: Listaries    # Callback Handlers
    recursion_limit: int    # Max steps
    configurable: Dict      # Runtime parameters
```

---

## 2. Passing Config

```python
chain.invoke(
    "Hello", 
    config={
        "run_name": "MySpecialRun",
        "tags": ["production", "urgent"],
        "metadata": {"user_id": 99}
    }
)
```

This metadata appears instantly in LangSmith traces.

---

## 3. Thread Pools (max_concurrency)

When you use `.batch()` or `.map()`, LCEL tries to run in parallel.

```python
# Default: standard max_workers
# Custom: Limit to 2 threads
chain.batch(inputs, config={"max_concurrency": 2})
```

Use this to prevent api rate limits or DB overload.

---

## 4. Recursion Limit

Crucial for **Agents** (Loops).

```python
# Stop after 5 iterations (default is usually 25)
agent.invoke(input, config={"recursion_limit": 5})
```

This prevents an LLM from looping forever: "I need to check the weather... I need to check the weather..."

---

## Quick Reference

| Key | Usage |
|-----|-------|
| **tags** | Filter traces |
| **metadata** | Store User ID / Session ID |
| **max_concurrency** | Rate limiting |
| **recursion_limit** | Infinite loop guard |
