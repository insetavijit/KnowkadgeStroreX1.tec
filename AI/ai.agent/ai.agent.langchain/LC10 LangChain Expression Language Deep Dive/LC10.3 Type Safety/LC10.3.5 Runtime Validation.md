| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.3.5.1 Validation Boundaries**           | Where to check                          | Validating at ingress (API) vs egress (LLM output)                            | Validate at the edges: Entry and Exit.                          |
| **LC10.3.5.2 Handling ValidationErrors**       | Error management                        | Try/Except blocks, corrective prompting, re-asking                            | Catch ValidationErrors to trigger specific recovery logic.      |
| **LC10.3.5.3 Validator Functions**             | Custom logic                            | Pydantic @validator, identifying semantic errors (e.g., date ranges)          | Use Pydantic validators for logic beyond type checking.         |
| **LC10.3.5.4 Sanitization**                    | Cleaning data                           | Trimming whitespace, normalization before validation                          | Sanitize input before validating to reduce false rejects.       |
| **LC10.3.5.5 The Validation Chain**            | Composition pattern                     | Linking generation → validation → retry                                       | Compose validation steps directly into the chain.               |

# Runtime Validation: Trust But Verify

Static types help developers. Runtime validation helps users. In an LLM system, "users" include the Model itself, which often acts like a chaotic user inputting random text.

---

## 1. Validation Boundaries

Treat your chain like a fortress.

1.  **Ingress (User Input)**: Validate strictly. Don't let garbage enter the prompt.
2.  **Core (Logic)**: Trust the data (it was validated at ingress).
3.  **Egress (Model Output)**: Validate strictly. Don't let hallucinations break the UI.

---

## 2. Handling ValidationErrors

When Pydantic fails, it raises `ValidationError`.

```python
from pydantic import ValidationError

try:
    chain.invoke(bad_input)
except ValidationError as e:
    # Return a friendly error to user
    return f"Invalid input: {e}"
```

### Self-Correction (Retry)

If the **Model** output fails validation, ask it to try again.

```python
# Pseudo-code for retry loop
for _ in range(3):
    result_text = llm.invoke(prompt)
    try:
        obj = parser.parse(result_text)
        return obj
    except ValidationError as e:
        # Feed error back to model
        prompt += f"\nError: {e}. Try again."
```

LangChain's `RetryOutputParser` automates this.

---

## 3. Validator Functions (Semantic checks)

Types aren't enough. `age: int` allows `-5`. Use validators.

```python
from pydantic import validator

class User(BaseModel):
    age: int

    @validator("age")
    def check_age(cls, v):
        if v < 0 or v > 120:
            raise ValueError("Age must be realistic")
        return v
```

This prevents logical absurdities from propagating.

---

## 4. The Validation Chain Pattern

LCEL allows you to compose validation as a step.

```python
# A chain that validates the output of the previous step
validation_step = RunnableLambda(lambda x: MyModel(**x))

chain = (
    ... 
    | json_parser      # Returns dict
    | validation_step  # returns MyModel or raises Error
)
```

By making validation a distinct Runnable, you can attach fallbacks specifically to it.

```python
# If validation fails, try the fallback chain
safe_chain = chain.with_fallbacks([fallback_chain])
```

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **Ingress/Egress** | Validate external data entering and leaving |
| **ValidationError** | Pydantic's exception for invalid data |
| **@validator** | Custom logic (ranges, regex, logic) |
| **Retry** | Use validation errors to prompt the LLM to fix itself |
| **Recovery** | Attach fallbacks to validation steps |
