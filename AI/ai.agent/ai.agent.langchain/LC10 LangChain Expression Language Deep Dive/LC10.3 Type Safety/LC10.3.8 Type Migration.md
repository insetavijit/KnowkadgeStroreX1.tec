| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.3.8.1 The Untyped Legacy**              | The problem space                       | Old chains using Dict[str, Any] everywhere                                    | Legacy code is often untyped; migration manages chaos.          |
| **LC10.3.8.2 Gradual Typing Strategy**         | How to start                            | Start with leaves (simple functions), move to nodes (chains)                  | Add types from the bottom up (leaves first).                    |
| **LC10.3.8.3 The Facade Pattern**              | Wrapping legacy code                    | Putting a typed shell around an untyped chain                                 | Wrap untyped chains in typed Runnables to contain the mess.     |
| **LC10.3.8.4 Runtime Metrics**                 | Verifying migration                     | Logging type errors without crashing (monitor mode)                           | Monitor type errors before enforcing them.                      |
| **LC10.3.8.5 Adoption Roadmap**                | Steps to success                        | 1. Annotate Inputs 2. Annotate Outputs 3. Enforce Mypy                        | Follow a phased roadmap for typing adoption.                    |

# Type Migration: Taming the Wild West

You typically inherit a codebase with zero types. "Just rewrite it" is not an option. You need a **gradual migration strategy**.

---

## 1. The Strategy: Leaf Nodes First

Don't try to type the main `agent.py` first. It depends on everything.
Start with the **utilities**.

1.  Type `utils.py` (simple text formatters).
2.  Type custom `RunnableLambda` functions.
3.  Type sub-chains.
4.  Finally, type the main application flow.

---

## 2. The Facade Pattern

If you have a giant legacy chain that is too hard to type internaly, **wrap it**.

```python
# untyped_legacy.py
legacy_chain = (complex mess...)

# main.py
class LegacyInput(TypedDict):
    q: str

# Create a typed boundary
typed_chain = legacy_chain.with_types(input_type=LegacyInput, output_type=str)
```

Now, at least the *rest* of your application treats it as a respectable, typed citizen.

---

## 3. Monitor Mode (Runtime)

Before turning on strict Pydantic validation (which crashes the app on error), use **soft validation**.

```python
def soft_validate(x):
    try:
        MyModel(**x)
    except ValidationError:
        logger.warning("Type mismatch detected!", exc_info=True)
    return x
```

Insert this probe into your production chains. Fix the logs. *Then* switch to strict validation.

---

## Quick Reference

| Phase | Action |
|-------|--------|
| **1. Facade** | Wrap untyped chains with `.with_types()` |
| **2. Leaves** | Annotate simple helper functions |
| **3. Monitor** | Log validation errors but don't crash |
| **4. Enforce** | Turn on `mypy` and strict Pydantic |
