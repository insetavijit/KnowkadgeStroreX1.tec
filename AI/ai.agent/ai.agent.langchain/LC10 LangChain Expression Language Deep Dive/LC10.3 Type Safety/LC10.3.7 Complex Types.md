| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.3.7.1 Union Types**                     | Handling alternatives                   | Union[str, dict], "or" logic types                                            | Use Union for inputs that can be valid in multiple forms.       |
| **LC10.3.7.2 Optional Types**                  | Handling missing data                   | Optional[str], default values, null safety                                    | Use Optional for data that might not exist.                     |
| **LC10.3.7.3 Recursive Types**                 | Nested structures                       | JSON structures, trees, self-referential types                                | Handle recursive data structures like JSON trees.               |
| **LC10.3.7.4 Generics in Depth**               | Reusable components                     | TypeVar, Generic[T], parameterized Chains                                     | Use Generics to write component libraries.                      |
| **LC10.3.7.5 Intersection Types**              | Combining schemas                       | Merging two TypedDicts (advanced usage)                                       | Combining contracts (rare but powerful).                        |

# Complex Types: Beyond Primitives

Real-world AI data is rarely just `string` or `int`. It's "maybe a string, or maybe a list of images," or "a dictionary that might have a history key."

---

## 1. Union Types (The "Either/Or")

Common in inputs that support multimodal data.

```python
from typing import Union

# Accepts text OR a list of messages
InputType = Union[str, list[BaseMessage]]

chain = RunnableLambda(
    lambda x: x if isinstance(x, str) else x[0].content,
    input_type=InputType
)
```

Mypy will force you to handle both cases inside the logic (using `isinstance`).

---

## 2. Optional Types (The "Maybe")

If a key might be missing, mark it Optional.

```python
from typing import Optional

class Context(TypedDict):
    docs: str
    metadata: Optional[dict]

# Code must handle None
def process(c: Context):
    meta = c["metadata"] or {}  # Safe fallback
```

---

## 3. Generics (The "For Any T")

Writing a wrapper that doesn't care about the payload? Use Generics.

```python
T = TypeVar("T")

def log_passthrough(x: T) -> T:
    print(x)
    return x

# This Runnable preserves the type of whatever passes through it
logger = RunnableLambda(log_passthrough)

# str -> str
chain1 = prompt | logger | llm 

# dict -> dict
chain2 = {"a": ...} | logger | ...
```

This ensures you don't accidentally "erase" the type information to `Any`.

---

## Quick Reference

| Type | Syntax | Usage |
|------|--------|-------|
| **Union** | `Union[A, B]` | Input is A OR B |
| **Optional** | `Optional[A]` | Input is A OR None |
| **List** | `List[A]` | Sequence of A |
| **Generic** | `TypeVar("T")` | Preserves type across transformation |
