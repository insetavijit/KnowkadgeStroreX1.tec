| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.3.3.1 Explicit Typing**                 | Annotating Runnables                    | .with_types(), annotating Lambdas, defining generics                          | Explicitly declare input/output types for custom chains.        |
| **LC10.3.3.2 Type Propagation**                | How strictness flows                    | Strict inputs enforce upstream strictness, loose inputs accept anything       | Types propagate down the chain; strictness propagates up.       |
| **LC10.3.3.3 Generic Aliases**                 | Reusable type definitions               | Runnable[str, str], Runnable[Dict, AIMessage]                                 | Use aliases for common Runnable signatures.                     |
| **LC10.3.3.4 Analyzing Chains**                | Introspection                           | chain.get_input_schema(), chain.get_output_schema()                           | Programmatically inspect a chain's expected types.              |
| **LC10.3.3.5 Schema Generation**               | Automatic API docs                      | JSON schema from Runnables for generic UIs (LangServe)                        | Chains generate JSON schemas automatically.                     |

# Input/Output Types: The Data Contract

Every Runnable has an `InputType` and an `OutputType`. Controlling these explicit definitions allows you to turn a loose script into a robust API endpoint that self-documents.

---

## 1. Explicit Typing

When you create a `RunnableLambda`, the types are inferred from the function signature.

```python
def my_func(x: int) -> str:
    return str(x)

# Inferred: Input=int, Output=str
runnable = RunnableLambda(my_func)
```

### Overriding Types

Sometimes inference fails (e.g., confusing lambdas). Use `with_types()`.

```python
chain = (
    prompt | llm
).with_types(input_type=MyInputModel, output_type=str)
```

This forces the chain to report `MyInputModel` as its input schema, regardless of what the prompt technically accepts.

---

## 2. Type Propagation

Types flow **downstream**.

1.  Step 1 Input: `int`
2.  Step 1 Output: `str`
3.  Step 2 Input: Must be `str` (or Any)

If Step 2 strictly requires `dict`, and Step 1 outputs `str`, static analysis (Mypy) will flag it.

---

## 3. Generic Aliases

For readability, type your chain variables.

```python
from langchain_core.runnables import Runnable

# A chain that takes a topic (str) and returns a summary (str)
SummaryChain = Runnable[str, str]

def build_summary_chain() -> SummaryChain:
    return prompt | llm | parser

chain: SummaryChain = build_summary_chain()
```

---

## 4. Analyzing Chains (Introspection)

You can ask a running chain: "What do you expect?"

```python
print(chain.input_schema.schema_json())
```

**Output**:
```json
{
  "title": "ChainInput",
  "type": "object",
  "properties": {
    "topic": {"type": "string"}
  },
  "required": ["topic"]
}
```

This is how **LangServe** works. It reads your chain's schema and automatically generates a Swagger UI.

---

## 5. Schema Generation

LangChain automatically generates Pydantic schemas for any Runnable.

*   `chain.input_schema` -> Pydantic Model class
*   `chain.output_schema` -> Pydantic Model class

```python
InputModel = chain.input_schema
valid_input = InputModel(topic="AI")
```

If you used `TypedDict` or `Pydantic` models inside your chain, these schemas will reflect that structure accurately.

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **with_types()** | Manually override the declared types of a chain |
| **Introspection** | `.input_schema` / `.output_schema` properties |
| **Inference** | Derived from function signatures and component contracts |
| **LangServe** | Uses these schemas to build API UIs automatically |
| **Benefit** | **Self-Documentation**: Code describes its own interface |
