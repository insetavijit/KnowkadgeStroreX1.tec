| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.3.4.1 Mypy Integration**                | Static Analysis                         | Configuring mypy, strictness levels, catching errors before running           | Use mypy to catch type errors at build time.                    |
| **LC10.3.4.2 IDE Autocompletion**              | Developer Experience                    | Type hints enabling dot-access intellisense                                   | Type hints make the IDE helpful.                                |
| **LC10.3.4.3 Common Typing Errors**            | Pitfalls                                | Any vs object, Optional handling, Union types in chains                       | Avoid 'Any' to keep static checking useful.                     |
| **LC10.3.4.4 Typing Custom Runnables**         | Extending the framework                 | Subclassing RunnableSerializable, generic type vars                           | Properly type custom classes to maintain the chain of trust.    |
| **LC10.3.4.5 Variance & Covariance**           | Advanced theory                         | Why Input must be contravariant and Output covariant                          | Inputs accept wider types; outputs produce narrower types.      |

# Type Checking: The Build-Time Guard

**Runtime validation** (Pydantic) protects your app from bad data.
**Static type checking** (Mypy/Pyright) protects your app from bad code.

LCEL is designed to be statically analyzable.

---

## 1. Mypy Integration

To get the most out of LangChain, run Mypy.

`mypy.ini`:
```ini
[mypy]
disallow_untyped_defs = True
ignore_missing_imports = True
```

When you define a chain:

```python
chain: Runnable[dict, str] = prompt | llm | parser
```

Mypy verifies that `prompt` accepts `dict` and `parser` outputs `str`. If you swap them, Mypy yells.

---

## 2. IDE Autocompletion

Types aren't just for errors; they are for speed.

```python
class Output(TypedDict):
    summary: str
    keywords: list[str]

chain: Runnable[str, Output] = ...

result = chain.invoke("...")

# When you type "result.", VS Code suggests:
#  - summary
#  - keywords
```

Without types, `result` is `Any`, and you are flying blind.

---

## 3. Common Typing Errors

### The "Silent Any"
If you don't annotate `lambda x: x`, Python infers the return type as `Any`. This breaks the type chain.

**Fix**:
```python
# Bad
RunnableLambda(lambda x: x["key"])

# Good
RunnableLambda(lambda x: x["key"], input_type=dict, output_type=str)
```

### The "Optional" Trap
If a step *might* return None, the next step must accept `Optional[T]`.

```python
def safe_get(x):
    return x.get("optional_key")  # Returns str | None

# Next step must handle None
chain = RunnableLambda(safe_get) | RunnableLambda(lambda x: x.upper() if x else "")
```

---

## 4. Typing Custom Runnables

When subclassing `Runnable`, use Generics.

```python
from typing import TypeVar
from langchain_core.runnables import RunnableSerializable

Input = TypeVar("Input")
Output = TypeVar("Output")

class MyCustomStep(RunnableSerializable[Input, Output]):
    def invoke(self, input: Input, config=None) -> Output:
        ...
```

This tells Mypy exactly the contract this class fulfills.

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **Mypy** | Static type checker for Python |
| **Analyzability** | LCEL chains allow static verification of composition |
| **IDE Tips** | Annotate lambdas to get autocomplete downstream |
| **Generics** | Use TypeVars when creating reusable components |
| **Benefit** | **Safety**: Catch composition bugs before the code runs |
