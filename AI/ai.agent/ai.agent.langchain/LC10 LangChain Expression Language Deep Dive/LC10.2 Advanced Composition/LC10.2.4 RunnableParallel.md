| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.2.4.1 Definition & Syntax**             | Define parallel class                   | RunnableParallel, dict syntax, concurrent execution                           | RunnableParallel runs multiple branches at once.                |
| **LC10.2.4.2 Implicit vs Explicit**            | How to create it                        | Dict literal coercion vs RunnableParallel constructor                         | A dict in a chain automatically becomes a RunnableParallel.     |
| **LC10.2.4.3 Result Merging**                  | How output is formed                    | Output is a dict, keys match input branches                                   | Returns a dictionary with results from all branches.            |
| **LC10.2.4.4 Passthrough Patterns**            | Keeping context                         | Using 'input' key to keep original data, non-destructive branches             | Use parallel to add new data while keeping old data.            |
| **LC10.2.4.5 Performance Gains**               | Why use it                              | Latency reduction, simultaneous API calls                                     | Parallelizing independent steps reduces total latency.          |

# RunnableParallel: The Power of Concurrency

`RunnableParallel` allows a chain to "fork" into multiple paths that run simultaneously. It is the key to **reducing latency** and **merging data** from multiple sources.

---

## 1. Definition and Syntax

`RunnableParallel` runs a set of Runnables on the *same input* and returns a dictionary of results.

```python
from langchain_core.runnables import RunnableParallel

# Explicit
parallel = RunnableParallel(
    context=retriever,
    question=RunnablePassthrough()
)

# Implicit (Syntactic Sugar)
# Within a chain, a dict is automatically cast to RunnableParallel
chain = {
    "context": retriever,
    "question": RunnablePassthrough()
} | prompt | model
```

**Key Insight**: The dictionary syntax you see in almost every RAG chain *is* a `RunnableParallel`.

---

## 2. Execution Model: Fan-Out, Fan-In

1.  **Fan-Out**: The input is sent to *every* branch simultaneously.
2.  **Execution**: Each branch processes the input independently (and concurrently in async).
3.  **Fan-In**: The system waits for *all* branches to finish.
4.  **Result**: A single dictionary is returned.

```
       Input
      /     \
  BranchA  BranchB
      \     /
    {a:ResA, b:ResB}
```

---

## 3. Result Merging

The output is always a dictionary where keys match the definition.

```python
chain = RunnableParallel({
    "age": get_age_chain,
    "name": get_name_chain
})

result = chain.invoke("User ID 123")
# Result: {"age": 30, "name": "Alice"}
```

This dictionary is perfectly shaped to be the input for a `PromptTemplate`. This is why parallel blocks usually precede prompts.

---

## 4. The Passthrough Pattern (Context Preservation)

A common problem: "I need to calculate X, but I also need to keep the original Input."

**Solution**: One branch calculates X, one branch passes input through.

```python
from langchain_core.runnables import RunnablePassthrough

# Input: {"text": "some text"}
chain = RunnableParallel({
    "analysis": analyze_text_chain,      # Calculates new thing
    "original": RunnablePassthrough()    # Keeps old thing
})
# Output: {"analysis": "...", "original": {"text": "some text"}}
```

The `RunnablePassthrough.assign()` method is a shorthand for this pattern:

```python
# Adds 'analysis' key to the input dict, keeps everything else
chain = RunnablePassthrough.assign(analysis=analyze_text_chain)
```

---

## 5. Performance Gains

In sequential chains, independent steps block each other.
`A â†’ B` takes `Time(A) + Time(B)`.

In parallel chains, they race.
`{A, B}` takes `max(Time(A), Time(B))`.

### Example: Multi-Source RAG

Retrieve from Wiki, Google, and Archive simultaneously.

```python
chain = RunnableParallel({
    "wiki": wiki_retriever,
    "google": google_search,
    "archive": archive_retriever
}) | prompt | model
```

If Wiki takes 1s, Google 2s, Archive 0.5s:
*   **Sequential**: 3.5s
*   **Parallel**: 2.0s (Wait for the slowest)

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **RunnableParallel** | Runs multiple branches on same input |
| **Dict Syntax** | `{ "key": chain }` creates one implicitly |
| **Output** | A dictionary merging all results |
| **Passthrough** | Use to augment input without losing original data |
| **Performance** | Total time = Time of slowest branch |
| **Benefit** | **Concurrency**: Speed up independent operations |
