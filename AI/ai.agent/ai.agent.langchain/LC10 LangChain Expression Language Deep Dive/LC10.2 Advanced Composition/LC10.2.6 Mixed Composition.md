| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.2.6.1 Hybrid Architectures**            | Combine Patterns                        | Seq(Par(Seq, Par)), mixing parallel and serial flows                          | Complex workflows mix sequential and parallel blocks freely.    |
| **LC10.2.6.2 Fan-Out/Fan-In Cycles**           | Repeated branching                      | Expanding context → processing → merging → expanding again                    | Alternate between divergence (Fan-Out) and convergence (Fan-In).|
| **LC10.2.6.3 Conditional Parallelism**         | Dynamic branching                       | Running branches only if condition applies (requires Router)                  | Execute parallel branches selectively based on logic.           |
| **LC10.2.6.4 State Management in Mixes**       | Keep track of variables                 | Passing state through mixed layers, avoiding overrides                        | Use precise key mapping to manage state across hybrid layers.   |
| **LC10.2.6.5 The "Diamond" Problem**           | Dependency management                   | Ensuring convergent steps wait for all divergent ancestors                    | Converging steps implicitly wait for all upstream branches.     |

# Mixed Composition: Hybrid Architectures

Real-world problems rarely fit neatly into *just* a "Sequence" or *just* a "Parallel" block. They are **Hybrid**: sequences that fork into parallels, which contain sequences, which merge back together.

---

## 1. Hybrid Architectures: The "Lego" Approach

In LCEL, `RunnableSequence` and `RunnableParallel` nests arbitrarily deep.

```python
# A Sequence containing a Parallel block, 
# which contains another Sequence
chain = (
    pre_process_step
    | RunnableParallel({
        "branch_a": (step_a1 | step_a2),     # Sequence inside Parallel
        "branch_b": step_b
    })
    | merge_step
)
```

**Key Insight**: To the outer chain, the entire `RunnableParallel` block is just **one step** that takes input and returns a dict.

---

## 2. Fan-Out / Fan-In Cycles

A common pattern for sophisticated reasoning:

1.  **Diverge**: Gather information from multiple sources.
2.  **Converge**: Synthesize the information.
3.  **Diverge**: Critique the synthesis from multiple angles.
4.  **Converge**: Finalize the answer.

```python
# Cycle 1: Gather
gather_step = RunnableParallel({
    "docs": retriever,
    "web": web_search
})

# Cycle 2: Synthesize
synthesize_step = (
    prompt_synth | llm_synth | StrOutputParser()
)

# Cycle 3: Critique
critique_step = RunnableParallel({
    "accuracy": accuracy_check_chain,
    "tone": tone_check_chain
})

# Build the sandwich
full_chain = (
    gather_step
    | synthesize_step
    | critique_step
    | final_revision_step
)
```

---

## 3. State Management in Mixed Chains

When mixing layers, you must track **data shape**.

*   Start: `{"topic": "AI"}`
*   After Gather: `{"docs": [...], "web": [...]}` (Note: "topic" might be lost unless passed through!)
*   After Synthesize: `"The summary is..."` (String! Previous context lost!)

**The Fix**: Use `RunnablePassthrough` to keep context alive across boundaries.

```python
# Bad: Context is lost after synthesis
chain = gather | synthesize | critique

# Good: Context is preserved
chain = (
    RunnablePassthrough.assign(data=gather)  # Keep input, add data
    | RunnablePassthrough.assign(summary=synthesize) # Keep data, add summary
    | critique
)
```

---

## 4. Conditional Parallelism

Sometimes you want parallel execution, but only *if* needed.

```python
# Mixed Router + Parallel
# If explicit inputs are missing, fetch them in parallel.
# Otherwise, just pass them through.

def route(info):
    if "context" in info:
        return RunnablePassthrough()  # Already have it
    else:
        return RunnableParallel({"context": retriever}) # Go get it

chain = (
    RunnableLambda(route)
    | prompt
    | llm
)
```

This dynamic composition allows chains to be **adaptive**.

---

## 5. The "Diamond" Topology

    Start
   /     \
  A       B
   \     /
     End

In LCEL, this topology is handled naturally by `RunnableParallel`.

```python
diamond = (
    start_step
    | RunnableParallel({
        "path_a": step_a,
        "path_b": step_b
    })
    | end_step
)
```

**Concurrency Guarantee**: `end_step` will NOT start until **both** `path_a` and `path_b` have finished. The synchronization barrier is implicit.

---

## 6. Example: The "Researcher" Agent

A hybrid chain that researches a topic:

```python
# 1. Generate 3 search queries (Sequence)
query_generator = prompt_q | llm | output_parser_list

# 2. Run all 3 queries (Parallel Map)
search_executor = query_generator | web_search_tool.map()

# 3. Summarize all 3 results (Sequence)
summarizer = (
    search_executor
    | (lambda results: "\n".join(r for r in results))
    | prompt_summary 
    | llm
)
```

This mixes: Sequence → Parallel (Map) → Sequence.

---

## Quick Reference

| Concept | Structure | Use Case |
|---------|-----------|----------|
| **Seq(Par)** | `A \| {B, C} \| D` | Split-Apply-Combine workflows |
| **Par(Seq)** | `{ "a": A\|B, "b": C }` | Independent multi-step sub-tasks |
| **Fan-Out/In** | Diverge → Converge | Synthesis and critique loops |
| **Diamond** | Split → Join | Redundant processing / Verification |
| **Context** | Use `assign` | Preserving variables across deep mixes |
