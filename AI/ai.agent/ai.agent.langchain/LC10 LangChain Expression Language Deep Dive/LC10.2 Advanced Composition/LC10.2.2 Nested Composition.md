| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.2.2.1 The Nesting Concept**             | Recursion in chains                     | Chains containing chains, fractal architecture                                | A chain can be a step in another chain.                         |
| **LC10.2.2.2 Scoping & Isolation**             | Manage namespace                        | Local vs global variables, encapsulated logic                                 | Nested chains isolate their internal logic and variables.       |
| **LC10.2.2.3 Reusable Sub-Chains**             | Create library code                     | Defining chains as functions/variables, importing chains                      | Define common workflows once, reuse them in many parents.       |
| **LC10.2.2.4 Input/Output Mapping**            | Connect layers                          | Mapping parent input to child input, bubbling child output                    | Explicitly map data entering and leaving the nested scope.      |
| **LC10.2.2.5 Flattening vs Nesting**           | Architectural choice                    | When to nest vs when to flatten, readability trade-offs                       | Nest for encapsulation; flatten for simple linearity.           |

# Nested Composition: Fractal Architecture

The power of LCEL lies in its **fractal nature**: a Chain is just a Runnable. This means a Chain can be composed into another Chain, which can be composed into yet another. This recursion allows you to build sophisticated systems from simple, self-contained units.

---

## 1. The Nesting Concept

Just as a function can call another function, a chain can invoke another chain.

```
┌──────────────────────────────────────────────┐
│                Parent Chain                  │
│                                              │
│  Step 1  →  [ Nested Chain ]  →  Step 3      │
│                  ↓                           │
│             ┌─────────────┐                  │
│             │  Step 2.1   │                  │
│             │     ↓       │                  │
│             │  Step 2.2   │                  │
│             └─────────────┘                  │
└──────────────────────────────────────────────┘
```

```python
# The child: A standalone summarizer
summarize_chain = (
    ChatPromptTemplate.from_template("Summarize: {text}")
    | ChatOpenAI()
    | StrOutputParser()
)

# The parent: A document processor
# Notice we just drop 'summarize_chain' in as a step
process_chain = (
    load_document_step
    | summarize_chain
    | email_step
)
```

**Key Insight**: The parent chain doesn't care that `summarize_chain` is complex. It just sees a Runnable that accepts Text and returns Text.

---

## 2. Scoping and Isolation

Nested chains provide **encapsulation**. The variable names inside the child chain don't leak out to the parent, and vice-versa, unless explicitly passed.

```python
# Child
child = Prompt("{inner_var}") | LLM

# Parent
parent = (
    {"inner_var": RunnablePassthrough()}  # Explicit mapping
    | child
)
```

This isolation prevents "variable collision"—where two parts of a large chain accidentally use the same variable name for different things.

---

## 3. Reusable Sub-Chains: The Library Pattern

You should define your generic logic as reusable chains.

`common_chains.py`:
```python
# A standard clean-up chain
clean_text_chain = (
    RunnableLambda(lambda x: x.strip())
    | RunnableLambda(lambda x: x.lower())
)

# A standard JSON parser chain
json_chain = (
    ChatOpenAI(model="gpt-3.5-turbo", response_format={"type": "json_object"})
    | JsonOutputParser()
)
```

`main.py`:
```python
from common_chains import clean_text_chain, json_chain

# Compose them
final_pipeline = clean_text_chain | specific_logic | json_chain
```

---

## 4. Input/Output Mapping

When connecting a parent to a child, you often need to **adapt the interface**.

### Scenario: Parent has `{doc, query}`, Child needs `{text}`

Use a `RunnableParallel` or `dict` to map the specific keys.

```python
# Child expects 'text'
child = PromptTemplate.from_template("Translate: {text}") | llm

# Parent has 'doc' and 'query'
parent = (
    {
        "text": lambda x: x["doc"],  # Map 'doc' to 'text'
        "original_query": lambda x: x["query"] # Keep query for later
    }
    | child
)
```

The dict at the start of `parent` acts as the **bridge** into the nested scope.

---

## 5. Flattening vs. Nesting

When should you nest?

| Pattern | Code Structure | Best For |
|---------|----------------|----------|
| **Flat** | `A | B | C | D` | Simple, linear sequences |
| **Nested** | `A | (B | C) | D` | Reusing `(B | C)` elsewhere |

**Rule of Thumb**: If a sequence of steps `(B | C)` performs a distinct logical task (e.g., "Summarize", "Translate", "Extract Entities"), wrap it in a variable (Nest it). If it's just arbitrary, distinct steps, keep it flat.

---

## 6. Visualization Impact

Nesting affects how LangSmith traces look.

*   **Flat**: One long list of steps.
*   **Nested**: A hierarchical tree. You can click to expand/collapse the sub-chain.

**Debugging Tip**: Nesting improves debuggability by grouping related operations. If the "Summarizer" fails, you see the error on the `SummarizeChain` node, rather than just "Step 4 failed".

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **Nesting** | Using a Chain as a step in another Chain |
| **Encapsulation** | Internal logic of child chain is hidden from parent |
| **Mapping** | Use dicts to translate parent variables to child inputs |
| **Reusability** | Define common sub-chains and import them |
| **Tracing** | Nesting creates hierarchical traces in LangSmith |
| **Benefit** | **Abstraction**: Manage complexity by hiding details |
