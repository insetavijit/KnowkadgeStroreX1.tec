| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.2.7.1 Visualization Strategy**          | See the chain                           | get_graph(), print_ascii(), conceptual mapping                                | Visualizing the graph reveals structural flaws.                 |
| **LC10.2.7.2 LangSmith Tracing**               | Trace execution                         | Inspecting inputs/outputs of every step, latency breakdown                    | LangSmith is the debugger for LCEL.                             |
| **LC10.2.7.3 Component Isolation**             | Unit testing parts                      | Invoking sub-chains independently, identifying the broken link                | Test each component separately to find the bug.                 |
| **LC10.2.7.4 Callback Debugging**              | Logging events                          | ConsoleCallbackHandler, set_debug(True), internal event stream                | Use verbose mode and callbacks to watch execution logs.         |
| **LC10.2.7.5 Common Composition Errors**       | Recognize patterns                      | Type mismatches, lost context, recursion depth, serialization                 | Watch for schema mismatches and missing context keys.           |

# Debugging Complex Chains: Seeing Inside the Black Box

LCEL chains are declarative, which makes them concise but sometimes opaque. When a 10-step chain fails, simply reading the code isn't enough. You need tools to inspect the runtime state.

---

## 1. Visualization Strategy: The Graph View

Before running the code, verify the **structure**. Did you connect A to B correctly?

```python
chain = (prompt | llm | parser)

# ASCII representation
chain.get_graph().print_ascii()
```

```
   +-------------+
   |   Prompt    |
   +-------------+
          *
          |
   +-------------+
   | ChatOpenAI  |
   +-------------+
          *
          |
   +-------------+
   |   Parser    |
   +-------------+
```

If the graph looks disconnected or wrong (e.g., Parallel steps following each other sequentially), your syntax is wrong.

---

## 2. LangSmith Tracing: The Gold Standard

LangSmith is the native debugger for LangChain. It captures:

1.  **Input/Output** of every nested Runnable.
2.  **Latency** of each step.
3.  **Errors** with full stack traces.
4.  **Token Usage**.

**Setup**:
```bash
export LANGCHAIN_TRACING_V2=true
export LANGCHAIN_API_KEY=...
```

When you run your chain, a detailed tree view appears in the dashboard. You can click into the "Parallel" block, see which branch failed, and why.

---

## 3. Component Isolation (Divide and Conquer)

If a complex chain fails, **don't debug the whole chain**.

```python
# The Broken Chain
full_chain = step1 | step2 | step3 | step4

# Debugging Approach:
# 1. Test Step 1 alone
print(step1.invoke(input)) 

# 2. Test Step 1 | Step 2
print((step1 | step2).invoke(input))

# 3. Test Step 3 with manual input
manual_input_for_3 = {...}
print(step3.invoke(manual_input_for_3))
```

Because every component is a Runnable, they are all independently executable. Isolate the failure to a specific step.

---

## 4. Callback Debugging (Verbose Mode)

For quick local debugging without external tools, use the console handler.

```python
from langchain.globals import set_debug

# Turns on global verbose logging
set_debug(True)

chain.invoke(input)
```

**Output**:
```text
[chain/start] Entering Chain run...
[llm/start] Entering LLM run...
[llm/end] [1.2s] LLM run finished. Output: "Hello"
[chain/end] [1.5s] Chain run finished.
```

Or attach a handler to a specific run:

```python
from langchain_core.tracers import ConsoleCallbackHandler

chain.invoke(input, config={'callbacks': [ConsoleCallbackHandler()]})
```

---

## 5. Common Composition Errors

### The "Schema Mismatch"
**Symptom**: `TypeError: Object of type 'AIMessage' has no len()`
**Cause**: You fed an `AIMessage` into a step that expected a `string`.
**Fix**: Add a `StrOutputParser()` in between.

### The "Lost Context"
**Symptom**: `KeyError: 'question'`
**Cause**: A previous step returned a string (the answer), and you tried to verify it against the `question`, but the `question` wasn't passed through.
**Fix**: Use `RunnablePassthrough.assign()` instead of a raw chain to keep the original input.

### The "Silent Failure"
**Symptom**: Chain runs but result is empty.
**Cause**: A `RunnableLambda` function returned `None` or an empty string, propagating emptiness downstream.
**Fix**: Inspect intermediate outputs using tracing.

---

## 6. Debugging Async Chains

Async stack traces can be messy. Use `astream_events` to watch progress in real-time.

```python
async for event in chain.astream_events(input, version="v2"):
    if event["event"] == "on_chain_error":
        print(f"Error in {event['name']}: {event['data']}")
```

This gives you a structured event log rather than a confusing traceback.

---

## Quick Reference

| Tool | Purpose | Command |
|------|---------|---------|
| **ASCII Graph** | Verify structure | `.get_graph().print_ascii()` |
| **LangSmith** | Full inspection | `export LANGCHAIN_TRACING_V2=true` |
| **Verbose Mode** | Console logging | `set_debug(True)` |
| **Isolation** | Unit testing | Run `step.invoke()` manually |
| **Callbacks** | Custom logging | `config={'callbacks': [...]}` |
