| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.2.3.1 Definition & Syntax**             | Define sequential class                 | RunnableSequence, pipe operator \|, constructor syntax                        | RunnableSequence is what the \| operator creates.               |
| **LC10.2.3.2 Execution Model**                 | How it runs                             | Step-by-step processing, data hand-off, blocking vs streaming                 | Executes steps in order, passing output N to input N+1.         |
| **LC10.2.3.3 First & Last Steps**              | Interface definition                    | InputType comes from first step, OutputType comes from last                   | sequence.Input = step1.Input; sequence.Output = stepN.Output.   |
| **LC10.2.3.4 Explicit Construction**           | Alternative to pipe                     | RunnableSequence(steps=[...]), programmatic building                          | You can build sequences programmatically without the pipe.      |
| **LC10.2.3.5 Sequence limitations**            | What it cannot do                       | No loops, no conditional branching (requires separate primitives)             | Sequences are strictly linear; no loops or jumps.               |

# RunnableSequence: The Backbone of Linearity

When you use the `|` operator, you are actually creating an instance of `RunnableSequence`. Understanding this class demystifies "magic" syntax and allows for powerful dynamic chain construction.

---

## 1. Definition and Syntax

`RunnableSequence` is the container for a linear list of Runnables.

```python
from langchain_core.runnables import RunnableSequence

# These are IDENTICAL:

# 1. Syntax Sugar (The Pipe)
chain = prompt | llm | parser

# 2. Explicit Class Usage
chain = RunnableSequence(first=prompt, middle=[llm], last=parser)
```

**Key Insight**: `|` is just an overload for `__or__` that creates a `RunnableSequence`.

---

## 2. The Execution Model

A sequence obeys strict linear logic:

```
Input → [Step 1] → Output1 → [Step 2] → Output2 → ... → [Step N] → Final Output
```

*   **Synchronous**: Calls `invoke` on step 1, waits, passes result to step 2...
*   **Asynchronous**: Calls `ainvoke` on step 1, awaits, passes result...
*   **Streaming**: If the *last* step streams, the sequence streams. Intermediate steps stream if they are compatible, otherwise they buffer.

---

## 3. Interface Inheritance (First & Last)

A Sequence is a chameleon. It adopts the types of its boundaries.

```
┌──────────────────────────────────────────────┐
│             RunnableSequence                 │
│                                              │
│  [Prompt]    →    [LLM]    →    [Parser]     │
│  (Input: Dict)                     (Output: Str)│
└──────────────────────────────────────────────┘
       ▲                                 ▲
       │                                 │
Sequence Input: Dict             Sequence Output: Str
```

If you check `chain.InputType`, it reports `Dict`. If you check `chain.OutputType`, it reports `Str`.

---

## 4. Explicit Construction: Dynamic Chains

Why use the class instead of `|`? **Dynamic generation**.

If you're building a chain based on user configuration (e.g., select-box in UI), you can't use static valid python syntax `|`. You need a list.

```python
# User selects 3 steps from a UI
user_steps = [load_step, filter_step, analyze_step]

if use_summary:
    user_steps.append(summary_step)

# Create chain dynamically
# Note: RunnableSequence constructor is flexible
dynamic_chain = RunnableSequence(*user_steps)  # Unpack list

dynamic_chain.invoke(input)
```

This allows for metaprogramming—writing code that writes chains.

---

## 5. Sequence Limitations

A Sequence is strictly linear.

*   **No Loops**: You cannot jump back to Step 1. (Use `Graph` or recursion for that).
*   **No Branching**: You cannot say "If X, go to Step 3, else Step 4". (Use `RunnableBranch` or `RunnableRouter` inside the sequence for that).

It is a **Straight Line**.

---

## 6. Under the Hood: Interaction with Other Primitives

When a Sequence meets a Parallel block:

```python
# Sequence contains a Parallel step
chain = (
    step1
    | {  # This dict creates a RunnableParallel implicitly
        "a": branch_a,
        "b": branch_b
    }
    | step3
)
```

The Sequence sees the middle block as just *one step*. It invokes it, waits for both branches, and passes the resulting dictionary to step 3.

---

## Quick Reference

| Concept | Key Point |
|---------|-----------|
| **RunnableSequence** | The class created by `A \| B \| C` |
| **Linearity** | Strictly sequential execution |
| **Typing** | Inherits Input from first, Output from last |
| **Dynamic** | Use `RunnableSequence(*list)` to build from variables |
| **Limitations** | No cycles, no jumps (DAG only) |
| **Benefit** | **Structure**: The fundamental unit of linear logic |
