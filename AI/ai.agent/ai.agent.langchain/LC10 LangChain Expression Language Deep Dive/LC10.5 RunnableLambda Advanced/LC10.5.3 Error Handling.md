| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.5.3.1 Exception Propagation**           | Default behavior                        | Errors bubble up and stop implementation                                      | Errors in lambdas stop the chain immediately.                   |
| **LC10.5.3.2 Custom Exceptions**               | Structured failure                      | Raising specific errors to be caught by with_fallbacks                        | Raise semantic errors, not just generic Exceptions.             |
| **LC10.5.3.3 The Return-None Pattern**         | Soft failure                            | Returning None/Empty instead of raising, filtering downstream                 | Return None to signal 'skip' without crashing.                  |
| **LC10.5.3.4 Safe Calling**                    | Defensive coding                        | Try/Except blocks inside the lambda function                                  | Wrap internal logic in try/except blocks.                       |
| **LC10.5.3.5 Configurable Retry**              | Recovery                                | Using .with_retry() on a lambda step                                          | Attach retry policies to flaky lambda steps.                    |

# Error Handling: Graceful Failures

When you write custom Python code, you introduce custom Python bugs. Handling these bugs within `RunnableLambda` is crucial for chain stability.

---

## 1. Exception Propagation

By default, an exception in a lambda crashes the `invoke` call.

```python
def failure(x):
    raise ValueError("Oops")

chain = step1 | failure | step2
# Raises ValueError, step2 never runs.
```

---

## 2. Safe Calling (Internal Try/Except)

If an error is recoverable (e.g., bad format), handle it inside.

```python
def safe_parse(text):
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return {} # Fallback to empty dict

chain = model | safe_parse
```

---

## 3. Configurable Retry

You can attach LangChain's retry logic to *your* code.

```python
import random

def flaky_api(x):
    if random.random() < 0.5:
        raise ConnectionError("Flaky!")
    return "Success"

# Automatically retry up to 3 times on ConnectionError
resilient_chain = RunnableLambda(flaky_api).with_retry(
    retry_if_exception_type=(ConnectionError,),
    stop_after_attempt=3
)
```

This is cleaner than writing a `while` loop inside your function.

---

## 4. The Return-None Pattern (Filter)

Sometimes, failure means "ignore this item".

```python
def validate(x):
    if not x.is_valid:
        return None # Signal failure
    return x

# Usage with a Filter Step
chain = (
    step1 
    | validate 
    | RunnableLambda(lambda x: x if x else None) # Short circuit?
    # Note: Short circuiting requires Branching or specific router logic
)
```

Implementation check: Standard chains don't stop on `None`. You need a Router:

```python
chain = step1 | validate | RunnableBranch(
    (lambda x: x is None, RunnablePassthrough()), # Do nothing/stop
    step2
)
```

---

## Quick Reference

| Strategy | Usage |
|----------|-------|
| **Try/Catch** | Internal handling inside the function |
| **.with_retry()** | External handling for transient errors |
| **Fallbacks** | Switch to alternative chain on failure |
| **Return None** | Soft failure (requires checking downstream) |
