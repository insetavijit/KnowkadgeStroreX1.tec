| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.5.1.1 Wrapper Mechanics**               | How it works                            | RunnableLambda(func) converts any callable into a Runnable                    | RunnableLambda wraps Python functions to make them composable.  |
| **LC10.5.1.2 The Invoke Signature**            | Interface                               | (input, config) -> output support                                             | Lambdas can optionally accept 'config' as a second argument.    |
| **LC10.5.1.3 Decorator Syntax**                | Clean code                              | @chain decorator shortcut                                                     | Use @chain to turn functions into Runnables easily.             |
| **LC10.5.1.4 Pickling & Serialization**        | Persistence                             | Why lambdas (vs def) matter for serialization support                         | Use named functions instead of anonymous lambdas for serialization. |
| **LC10.5.1.5 Implicit Coercion**               | Syntactic Sugar                         | Passing a raw function to \| automatically wraps it                           | The pipe operator automatically wraps functions in RunnableLambda. |

# Custom Functions: The Bridge to Python

You can't do everything with pre-built chains. You need standard Python logic: regex, math, API calls, data slicing. `RunnableLambda` is the bridge that lets you bring **any** Python code into the LCEL world.

---

## 1. Wrapper Mechanics

`RunnableLambda` wraps a function so it has `.invoke()`, `.batch()`, and `.stream()` methods.

```python
from langchain_core.runnables import RunnableLambda

def add_one(x):
    return x + 1

# Wrap it
runnable = RunnableLambda(add_one)

# Use it
print(runnable.invoke(1)) # 2
print(runnable.batch([1, 2, 3])) # [2, 3, 4] (Thread-pooled automatically!)
```

This gives your simple function superpowers like **concurrency** and **tracing** for free.

---

## 2. Implicit Coercion (The Pipe Magic)

You rarely need to type `RunnableLambda` explicitly.

```python
# These are equivalent:
chain = prompt | RunnableLambda(len)
chain = prompt | len
```

The `|` operator detects that `len` is a callable and wraps it for you.

---

## 3. The Invoke Signature (Config Access)

Standard functions take one argument (`input`).
If you need access to the `RunnableConfig` (for callbacks, run_id, tags):

```python
def my_func(x, config):
    print(f"Running iteration {config['configurable']}")
    return x

# LCEL detects the 2-arg signature and passes config
chain = RunnableLambda(my_func)
```

---

## 4. Decorator Syntax (@chain)

For complex logic that you want to act as a Chain.

```python
from langchain_core.runnables import chain

@chain
def specialized_chain(text):
    # You can use other runnables inside!
    token_count = len(text)
    if token_count > 1000:
        return long_chain.invoke(text)
    else:
        return short_chain.invoke(text)
```

This turns `specialized_chain` into a Runnable class instance immediately.

---

## 5. Pickling and Serialization

**Warning**: Anonymous lambdas `lambda x: x+1` cannot be pickled (serialized) easily. This breaks multiprocessing and LangServe usage.

**Best Practice**: Always use `def` for production chains.

```python
# Bad (Unpickleable)
chain = RunnableLambda(lambda x: x.upper())

# Good (Pickleable)
def to_upper(x): return x.upper()
chain = RunnableLambda(to_upper)
```

---

## Quick Reference

| Feature | Syntax | Details |
|---------|--------|---------|
| **Explicit** | `RunnableLambda(func)` | Manual wrapping |
| **Implicit** | `chain \| func` | Auto-wrapping via pipe |
| **Config** | `def f(x, config):` | Access runtime config |
| **Decorator** | `@chain` | Convert function to Chain |
| **Serialization** | Use `def`, not `lambda` | Critical for deployment |
