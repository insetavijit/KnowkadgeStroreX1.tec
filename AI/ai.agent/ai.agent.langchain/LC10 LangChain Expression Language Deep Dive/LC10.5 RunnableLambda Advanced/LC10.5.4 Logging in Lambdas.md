| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.5.4.1 Printing vs Logging**             | Best practices                          | print() is invisible in some envs; use standard logging or callbacks          | Don't print(); use logging or callbacks.                        |
| **LC10.5.4.2 Accessing Callbacks**             | Configuration                           | Using the 'config' argument to get the callbacks manager                      | Access callbacks via the config argument.                       |
| **LC10.5.4.3 Custom Callback Events**          | Tracing                                 | Dispatching custom events to LangSmith/LangFuse                               | Dispatch custom events to visualize internal logic.             |
| **LC10.5.4.4 Decorating for Tracing**          | Visualization                           | @traceable decorator and how it names the lambda in the graph                 | Name your lambdas for better trace graphs.                      |
| **LC10.5.4.5 Context Variables**               | Tagging                                 | Getting run_id, parent_run_id from context                                    | Use context to correlate logs with specific runs.               |

# Logging in Lambdas: Observability

When your lambda runs, does it make a sound? In production, if it isn't logged, it didn't happen.

---

## 1. Printing vs Logging

*   **Print**: Goes to stdout. Messy in threaded apps. Hard to filter.
*   **Logging**: Standard Python `logging`. Configurable levels.

```python
import logging
logger = logging.getLogger(__name__)

def my_func(x):
    logger.info(f"Processing {x}")
    return x
```

---

## 2. Dispatching Custom Events (LangSmith)

You can send custom signals to your tracing platform.

```python
from langchain_core.callbacks import CallbackManagerForChainRun
from langchain_core.runnables import RunnableLambda

async def my_func(x, config):
    # Dispatch custom event
    # (Note: Current api for ad-hoc events is via astream_events or custom callbacks)
    pass
```

Actually, the easiest way to add "tracing checkpoints" is to break your lambda into named steps.

```python
step1 = RunnableLambda(func1).with_config(run_name="Parsing")
step2 = RunnableLambda(func2).with_config(run_name="Filtering")
```

In LangSmith, you will see "Parsing" and "Filtering" as distinct bars.

---

## 3. Decorating for Tracing

Give your lambda a name!

```python
def hidden_logic(x): ...

# In trace: Shows as "RunnableLambda" (Generic)

chain = RunnableLambda(hidden_logic, name="CalculateMetrics")

# In trace: Shows as "CalculateMetrics"
```

Always name your Lambdas. It saves hours of debugging.

---

## 4. Context Variables (RunnableConfig)

The `config` object holds metadata.

```python
def log_metadata(x, config):
    tags = config.get("tags")
    user_id = config.get("metadata", {}).get("user_id")
    print(f"User {user_id} triggered this with tags {tags}")
    return x
```

This connects your low-level function to the high-level request context.

---

## Quick Reference

| Method | Usage |
|--------|-------|
| **run_name** | Names the step in the trace graph |
| **logging** | Standard python logs |
| **config["metadata"]** | Access request-level context (User ID) |
| **Purpose** | **Visibility**: Make black-box functions transparent |
