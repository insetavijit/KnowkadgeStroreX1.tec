| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.5.5.1 Pure vs Impure**                  | Concept                                 | Pure = Deterministic; Impure = Writes/Reads World                             | Distinguish between calculation and world-interaction.          |
| **LC10.5.5.2 Tool Calling Pattern**            | Interaction                             | Using Lambdas as Tools for Agents                                             | Lambdas can serve as lightweight Tools.                         |
| **LC10.5.5.3 File IO and DB**                  | Storage                                 | Writing outputs securely                                                      | Encapsulate IO in specific side-effect lambdas.                 |
| **LC10.5.5.4 Idempotency**                     | Safety                                  | Designing side effects that can run multiple times safely                     | Ensure side effects are idempotent (safe to retry).             |
| **LC10.5.5.5 The "Observer" Pattern**          | Monitoring                              | Watching the chain without touching it (Passthrough trick)                    | Use observers to watch data flow non-destructively.             |

# Side Effects: Interacting with Reality

A chain that only calculates is a calculator. A chain that sends emails, buys stocks, or updates databases is an **Agent**. Runnables with side effects are the hands of your system.

---

## 1. Pure vs Impure

*   **Pure**: `lambda x: x.upper()`
*   **Impure**: `lambda x: requests.post(url, x)`

Keep your chains 90% Pure. Isolate Impurity into specific steps.

```python
# Bad: Mixed Logic and IO
def process(x):
    y = x.upper()
    db.save(y) # Side effect buried
    return y

# Good: Separated
logic_step = RunnableLambda(lambda x: x.upper())
io_step = RunnableLambda(save_to_db) 

chain = logic_step | io_step
```

---

## 2. Tool Calling Pattern

You can turn any function into a tool for an Agent.

```python
from langchain_core.tools import tool

@tool
def send_email(to: str, body: str):
    """Sends an email."""
    # ... side effect ...
    return "Sent"

# Tools ARE Runnables!
result = send_email.invoke({"to": "...", "body": "..."})
```

Use `@tool` when you want the Model to call the function. Use `RunnableLambda` when the **Code** calls the function.

---

## 3. Idempotency

**Rule**: If your chain retries, your side effect runs twice.

*   **Dangerous**: `lambda x: charge_credit_card(x)`
*   **Idempotent**: `lambda x: charge_credit_card(x, idempotency_key=x.id)`

Always design side-effect lambdas to be safe if called multiple times on the same input.

---

## 4. The Observer (Passthrough) Pattern

Review: Using `RunnableLambda` to watch data.

```python
chain = (
    step1
    | RunnableLambda(lambda x: print(f"Observer: {x}") or x) # Returns x
    | step2
)
```

Use this for:
*   Real-time dashboard updates.
*   Audit logging.
*   Slack notifications ("Chain started...").

---

## Quick Reference

| Concept | Tip |
|---------|-----|
| **Isolation** | Keep side effects in their own steps |
| **Tools** | Use `@tool` for LLM-driven side effects |
| **Runnables** | Use `RunnableLambda` for hardcoded side effects |
| **Retry Safety** | Make sure IO is idempotent |
