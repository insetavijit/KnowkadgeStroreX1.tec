| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.5.7.1 Unit Testing Mechanics**          | Basics                                  | Invoking static inputs, asserting static outputs                              | Test lambdas as standalone functions first.                     |
| **LC10.5.7.2 Isolation**                       | Strategy                                | Testing the lambda without the LLM/DB                                         | Mock external dependencies to test logic in isolation.          |
| **LC10.5.7.3 Mocking Config**                  | Advanced                                | Passing mock settings via config                                              | Use config to inject mock behavior during tests.                |
| **LC10.5.7.4 Integration Testing**             | In context                              | Testing the lambda within a small chain                                       | Verify the lambda works when connected to other steps.          |
| **LC10.5.7.5 Property Testing**                | Robustness                              | Fuzzing inputs to ensure no crashes                                           | Ensure lambda handles edge cases (None, empty lists) gracefully.|

# Testing Lambdas: Quality Assurance

Because `RunnableLambda` contains custom code, it is the most likely place for your chain to break. Test it rigorously.

---

## 1. Unit Testing mechanics

Since a `RunnableLambda` wraps a function, **test the function**.

```python
def my_logic(x):
    return x.split(":")[1]

# Test
def test_my_logic():
    assert my_logic("Key:Value") == "Value"
```

Don't test the *Runnable* wrapper unless you are testing LCEL features (like config). Test the business logic inside.

---

## 2. Isolation (Mocking)

If your lambda calls an API, mock it.

```python
from unittest.mock import MagicMock

def fetch_data(x, api_client):
    return api_client.get(x)

def test_fetch():
    mock_api = MagicMock()
    mock_api.get.return_value = "Success"
    
    # Inject dependency (Partial application)
    from functools import partial
    chain = RunnableLambda(partial(fetch_data, api_client=mock_api))
    
    assert chain.invoke("url") == "Success"
```

---

## 3. Integration Testing

Does it fit the socket?

Check Input/Output schema compatibility.

```python
def test_chain_compat():
    # Step A returns int
    step_a = RunnableLambda(lambda x: 1).with_types(output_type=int)
    
    # Step B expects str?
    def step_b_func(x: str): return x
    step_b = RunnableLambda(step_b_func)
    
    # This should technically work in Python (dynamic), 
    # but Mypy triggers error, or logic might break.
    
    result = (step_a | step_b).invoke("Start")
    # Verify result at boundary
```

---

## Quick Reference

| Test Type | Target |
|-----------|--------|
| **Unit** | The inner Python function (Logic) |
| **Integration** | The `RunnableLambda` in a chain (Architecture) |
| **Mock** | External calls inside the lambda |
