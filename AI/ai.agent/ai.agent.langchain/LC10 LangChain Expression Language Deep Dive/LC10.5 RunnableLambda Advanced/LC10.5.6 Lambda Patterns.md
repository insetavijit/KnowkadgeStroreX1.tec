| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC10.5.6.1 The "Get" Pattern**               | Extraction                              | itemgetter vs lambda x: x['key']                                              | Use itemgetter for cleaner dictionary extraction.               |
| **LC10.5.6.2 The "Coalesce" Pattern**          | Default values                          | lambda x: x or "Default"                                                      | Handle None/Empty values with a coalesce lambda.                |
| **LC10.5.6.3 The "Routing" Lambda**            | Dynamic Flow                            | Returning a Runnable from a Runnable (Metaprogramming)                        | A lambda can return another Runnable to be executed.            |
| **LC10.5.6.4 The "State Updater"**             | Mutation                                | Merging input and result                                                      | Update state by merging new results into the input dict.        |
| **LC10.5.6.5 The "JSON Fixer"**                | Sanitization                            | Parsing broken JSON from LLMs                                                 | Use lambdas to patch/fix bad output formats.                    |

# Lambda Patterns: Solutions to Common Problems

There are 5-6 one-liners that you will write a thousand times. Learn them, name them, reuse them.

---

## 1. The "Get" Pattern

Extracting a value from a dict.

```python
from operator import itemgetter

# Verbose
RunnableLambda(lambda x: x["question"])

# Clean (and Pickleable!)
itemgetter("question")
```

`itemgetter` is a perfectly valid Runnable.

---

## 2. The "Coalesce" Pattern

Handling emptiness.

```python
# If retrieval failed, use fallback text
fallback_if_empty = RunnableLambda(lambda x: x if x else "No info available.")

chain = retriever | fallback_if_empty | prompt
```

---

## 3. The "Routing" Lambda (Dynamic Dispatch)

A Lambda can return a Runnable!

```python
def route_by_user(user_type):
    if user_type == "admin":
        return admin_chain
    else:
        return user_chain

# This doesn't just return the OBJECT 'admin_chain', 
# it automagically INVOKES it if used in a chain context?
# NO. In LCEL, this usually returns the object. You need to coerce it.

chain = RunnableLambda(route_by_user) 
# Limitation: This returns the Runnable object, it doesn't run it.
# To run it dynamically, use RunnableBranch or specialized Router.
```

Correction: `RunnableLambda` returns data. To run the *returned* runnable, you used to need weird tricks. Now, use `RunnableBranch` or `Router`.

**However**, for *configuration*:
```python
chain = RunnableLambda(lambda x: prompt1 if x["lang"]=="en" else prompt2) | llm
# This works because PromptValue (output of prompt) is data.
# It does NOT work if you return a Chain object.
```

---

## 4. The "State Updater"

Merging data.

```python
def merge_result(inputs):
    # inputs is (original, validation_result)
    orig, valid = inputs
    return {**orig, "valid": valid}

chain = RunnableParallel(RunnablePassthrough(), step) | merge_result
```

---

## Quick Reference

| Pattern | Code |
|---------|------|
| **Extract** | `itemgetter("key")` |
| **Default** | `lambda x: x or "default"` |
| **Format** | `lambda x: f"User said: {x}"` |
| **Logic** | `lambda x: x > 5` |
