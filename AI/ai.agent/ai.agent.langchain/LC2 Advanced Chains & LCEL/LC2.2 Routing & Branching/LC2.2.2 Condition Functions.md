| **Subtopic**                                          | **Focus & Purpose**                          | **Key Concepts / Details**                                                      | **One-Line Recall**                                                 |
| ----------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **[[LC2.2.2.1 Writing Condition Functions]]**         | Create branch conditions                     | Function signature, return bool, input access                                   | Condition functions take input and return True/False.               |
| **[[LC2.2.2.2 Input Inspection]]**                    | Examine inputs for routing                   | Accessing input fields, type checking, value inspection                         | Inspect input to determine which branch to execute.                 |
| **[[LC2.2.2.3 Boolean Returns]]**                     | Use boolean logic                            | Truthy/falsy values, explicit bool, clear conditions                            | Conditions must return boolean to select branches.                  |
| **[[LC2.2.2.4 Condition Function Signatures]]**       | Define proper signatures                     | Input parameter, return type, type hints                                        | Conditions take single input and return bool.                       |
| **[[LC2.2.2.5 Complex Conditions]]**                  | Build sophisticated logic                    | Multiple checks, compound conditions, helper functions                          | Combine multiple checks in complex condition functions.             |

# Condition Functions: The Logic Gates

A `RunnableBranch` is only as good as its **Predicates**.
A predicate is a function `f(x) -> bool`.

---

## 1. The Anatomy of a Predicate

The condition function receives the **Output of the Previous Step**.

```python
# The Previous Step
input_state = {
    "question": "What is 2+2?",
    "topic": "math"
}

# The Predicate
def is_math_question(state: dict) -> bool:
    # 1. Type Safety
    if not isinstance(state, dict):
        return False
    # 2. Key Check
    return state.get("topic") == "math"
```

**Architectural Rule**:
Conditions should be **Side-Effect Free** and **Fast**.
Do NOT call an LLM inside a condition function. If you need LLM logic, run the LLM *before* the branch and pass the result to the condition.

---

## 2. Using Lambdas (Inline Logic)

For simple checks, use Lambdas to keep the definition close to usage.

```python
branch = RunnableBranch(
    (lambda x: len(x["docs"]) == 0, fallback_chain),  # No docs found?
    (lambda x: "error" in x, error_chain),            # Upstream error?
    rag_chain                                         # Happy Path
)
```

---

## 3. State Inspection Patterns

### A. The "Topic" Check
Checking a classification label generated by a previous router.
`lambda x: x["route"] == "finance"`

### B. The "Length" Check
Checking if retrieved documents are sufficient.
`lambda x: len(x["context"]) > 3`

### C. The "User Tier" Check
Checking metadata injected by the API layer.
`lambda x: x["metadata"]["user_tier"] == "premium"`

---

## Quick Reference

| Type | Example | Best For |
| :--- | :--- | :--- |
| **Lambda** | `lambda x: x > 5` | One-liners. |
| **Named Function** | `def is_valid(x): ...` | Complex validation regex. |
| **Class Method** | `self.check_auth` | Assessing database state. |
