| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC11.2.8.1 Batch Method**                    | Basic batching                          | Using .batch() for multiple images                                            | Use .batch() to process image lists in parallel.                |
| **LC11.2.8.2 Concurrency Control**             | Rate limiting                           | Using max_concurrency to throttle requests                                    | Set max_concurrency to avoid rate limits.                       |
| **LC11.2.8.3 Async Batch Processing**          | Scale                                   | Using abatch for high-volume workloads                                        | Use abatch for thousands of images.                             |
| **LC11.2.8.4 Progress Tracking**               | Monitoring                              | Tracking progress through batch processing                                    | Add progress bars for long batch jobs.                          |
| **LC11.2.8.5 Error Handling in Batch**         | Resilience                              | Handling failures without stopping entire batch                               | Use try/except to continue on individual failures.              |

# Batch Image Processing: Processing at Scale

When you have 100+ images to process, batch methods are essential.

---

## 1. Basic Batch Processing

LCEL's `.batch()` processes multiple inputs in parallel:

```python
from langchain_core.runnables import RunnableLambda

def build_caption_message(image_url: str):
    return [HumanMessage(content=[
        {"type": "text", "text": "Caption this image."},
        {"type": "image_url", "image_url": {"url": image_url}}
    ])]

chain = RunnableLambda(build_caption_message) | llm | StrOutputParser()

# Process 10 images in parallel
image_urls = ["url1", "url2", "url3", ...]
captions = chain.batch(image_urls)
```

---

## 2. Concurrency Control

Avoid rate limit errors with `max_concurrency`:

```python
config = {"max_concurrency": 5}  # Only 5 at a time

# Safe batching
captions = chain.batch(image_urls, config=config)
```

| Scale | Recommended max_concurrency |
|-------|----------------------------|
| **< 20 images** | 10-20 (default) |
| **20-100 images** | 5-10 |
| **100+ images** | 2-5 |

---

## 3. Async Batch Processing

For thousands of images, use `abatch`:

```python
import asyncio

async def process_all_images(urls: list[str]) -> list[str]:
    config = {"max_concurrency": 10}
    results = await chain.abatch(urls, config=config)
    return results

# Run
captions = asyncio.run(process_all_images(image_urls))
```

**Why async?**: Thread pools max out at ~100. Async scales to thousands.

---

## 4. Progress Tracking

Add progress monitoring for large batches:

```python
from tqdm import tqdm
import asyncio

async def process_with_progress(urls: list[str]) -> list[str]:
    results = []
    
    for url in tqdm(urls, desc="Processing images"):
        result = await chain.ainvoke(url)
        results.append(result)
    
    return results
```

Or use batch with callback:

```python
from langchain_core.callbacks import BaseCallbackHandler

class ProgressCallback(BaseCallbackHandler):
    def __init__(self, total: int):
        self.count = 0
        self.total = total
    
    def on_chain_end(self, outputs, **kwargs):
        self.count += 1
        print(f"Progress: {self.count}/{self.total}")
```

---

## 5. Error Handling in Batch

Don't let one failure kill the whole batch:

```python
async def safe_process(url: str) -> dict:
    try:
        caption = await chain.ainvoke(url)
        return {"url": url, "caption": caption, "error": None}
    except Exception as e:
        return {"url": url, "caption": None, "error": str(e)}

async def batch_with_errors(urls: list[str]) -> list[dict]:
    tasks = [safe_process(url) for url in urls]
    results = await asyncio.gather(*tasks)
    return results

# Results include both successes and failures
results = asyncio.run(batch_with_errors(image_urls))
successes = [r for r in results if r["error"] is None]
failures = [r for r in results if r["error"] is not None]
```

---

## Quick Reference

| Scale | Method | Concurrency |
|-------|--------|-------------|
| **< 10** | `.invoke()` loop | 1 |
| **10-100** | `.batch()` | 5-10 |
| **100-1000** | `.abatch()` | 10-20 |
| **1000+** | `.abatch()` + chunking | 2-5 |
