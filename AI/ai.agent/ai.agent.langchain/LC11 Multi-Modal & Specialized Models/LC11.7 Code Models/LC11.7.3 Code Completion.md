| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC11.7.3.1 Line Completion**                 | Inline                                  | Completing current line of code                                               | Complete the current line being typed.                          |
| **LC11.7.3.2 Multi-Line Completion**           | Block                                   | Generating multiple lines                                                     | Generate entire blocks from context.                            |
| **LC11.7.3.3 Context-Aware Completion**        | Smart                                   | Using surrounding code for context                                            | More context = better completions.                              |
| **LC11.7.3.4 Fill-in-the-Middle**              | FIM                                     | Completing code with prefix AND suffix                                        | FIM completes when you know before AND after.                   |
| **LC11.7.3.5 IDE Integration**                 | Tooling                                 | Integrating completion into editors                                           | Use APIs to power editor completions.                           |

# Code Completion: AI-Powered Autocomplete

Intelligent code completion beyond simple snippets.

---

## 1. Line Completion

Complete the current line:

```python
completion_prompt = ChatPromptTemplate.from_template("""
Complete this line of code. Return ONLY the completion, nothing else.

Context:
```python
{context}
```

Complete this line:
{partial_line}
""")

result = chain.invoke({
    "context": '''
def calculate_tax(income: float, rate: float = 0.2) -> float:
    """Calculate tax on income."""
    if income < 0:
        raise ValueError("Income cannot be negative")
    ''',
    "partial_line": "    return income *"
})
# Completion: " rate"
```

---

## 2. Multi-Line Completion

Generate entire blocks:

```python
multiline_prompt = ChatPromptTemplate.from_template("""
Complete this code. Generate the logical continuation.

```python
{code_prefix}
```

Generate the next 5-10 lines that logically follow.
""")

result = chain.invoke({
    "code_prefix": '''
class UserService:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def get_user(self, user_id: int):
    '''
})
```

---

## 3. Context-Aware Completion

Include relevant context for better completions:

```python
def get_completion_context(file_path: str, cursor_position: int) -> dict:
    """Gather context for completion."""
    with open(file_path) as f:
        content = f.read()
    
    return {
        "file_content": content,
        "imports": extract_imports(content),
        "functions": extract_function_signatures(content),
        "classes": extract_class_definitions(content),
        "cursor_line": get_line_at_position(content, cursor_position),
        "preceding_lines": content[:cursor_position].split('\n')[-20:]
    }
```

---

## 4. Fill-in-the-Middle (FIM)

When you have code before AND after:

```python
fim_prompt = ChatPromptTemplate.from_template("""
Fill in the missing code between PREFIX and SUFFIX.

PREFIX:
```python
{prefix}
```

[FILL HERE]

SUFFIX:
```python
{suffix}
```

Return only the code that goes in [FILL HERE].
""")

result = chain.invoke({
    "prefix": '''
def process_data(items: list[dict]) -> list[dict]:
    results = []
    for item in items:
    ''',
    "suffix": '''
    return results
    '''
})
# Should generate the loop body
```

---

## 5. Building a Completion API

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class CompletionRequest(BaseModel):
    code_before: str
    code_after: str = ""
    language: str = "python"
    max_tokens: int = 100

class CompletionResponse(BaseModel):
    completion: str
    confidence: float

@app.post("/complete")
async def complete_code(request: CompletionRequest) -> CompletionResponse:
    if request.code_after:
        # FIM mode
        result = fim_chain.invoke({
            "prefix": request.code_before,
            "suffix": request.code_after
        })
    else:
        # Standard completion
        result = completion_chain.invoke({
            "context": request.code_before
        })
    
    return CompletionResponse(
        completion=result.content,
        confidence=0.85
    )
```

---

## Quick Reference

| Mode | Use Case |
|------|----------|
| **Line** | Current line completion |
| **Multi-line** | Function body, class methods |
| **FIM** | Insert between existing code |
| **Context-rich** | Complex completions |
