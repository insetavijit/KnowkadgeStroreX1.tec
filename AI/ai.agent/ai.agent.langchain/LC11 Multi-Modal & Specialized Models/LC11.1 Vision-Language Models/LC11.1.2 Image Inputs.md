| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC11.1.2.1 URL Images**                      | Remote source                           | Passing HTTP(S) URLs directly to VLMs                                         | Use image URLs for remote images.                               |
| **LC11.1.2.2 Base64 Encoding**                 | Local files                             | Converting local files to base64 data URIs                                    | Encode local images as Base64 for API calls.                    |
| **LC11.1.2.3 Data URI Format**                 | Syntax                                  | `data:image/jpeg;base64,<encoded_data>`                                       | Data URIs embed image bytes in the message.                     |
| **LC11.1.2.4 File Size Limits**                | Constraints                             | Most APIs cap at 5-20MB; resolution limits (e.g. 2048x2048)                   | Check provider limits (usually 20MB max).                       |
| **LC11.1.2.5 Image Preprocessing**             | Optimization                            | Resizing, compressing before sending                                          | Resize images to save tokens and latency.                       |

# Image Inputs: URLs vs Base64

VLMs accept images in two ways: **URLs** (remote) or **Base64** (embedded).

---

## 1. URL Images (Simple)

If your image is publicly accessible on the internet:

```python
message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe this image."},
        {"type": "image_url", "image_url": {"url": "https://example.com/photo.jpg"}}
    ]
)
```

**Pros**: Simple, no encoding needed.
**Cons**: Image must be publicly accessible. OpenAI fetches it at call-time.

---

## 2. Base64 Encoding (Local Files)

For local images or private files:

```python
import base64

def encode_image(image_path: str) -> str:
    with open(image_path, "rb") as f:
        return base64.standard_b64encode(f.read()).decode("utf-8")

image_data = encode_image("./screenshot.png")

message = HumanMessage(
    content=[
        {"type": "text", "text": "What's in this screenshot?"},
        {
            "type": "image_url",
            "image_url": {
                "url": f"data:image/png;base64,{image_data}"
            }
        }
    ]
)
```

---

## 3. Data URI Format

The format is:
```
data:<mime_type>;base64,<encoded_data>
```

| File Type | MIME Type |
|-----------|-----------|
| **PNG** | `image/png` |
| **JPEG** | `image/jpeg` |
| **GIF** | `image/gif` |
| **WebP** | `image/webp` |

---

## 4. File Size & Resolution Limits

| Provider | Max Size | Max Resolution |
|----------|----------|----------------|
| **OpenAI** | 20 MB | 2048x2048 (auto-resized) |
| **Anthropic** | 5 MB | 8192x8192 |
| **Google** | 20 MB | Varies |

**Tip**: Always resize before sending to reduce token usage and latency.

---

## 5. Preprocessing Helper

```python
from PIL import Image
import io

def resize_image(path: str, max_size: int = 1024) -> str:
    img = Image.open(path)
    img.thumbnail((max_size, max_size))
    
    buffer = io.BytesIO()
    img.save(buffer, format="JPEG", quality=85)
    return base64.b64encode(buffer.getvalue()).decode()
```

---

## Quick Reference

| Method | When to Use |
|--------|-------------|
| **URL** | Public images, quick testing |
| **Base64** | Local files, private images, production |
| **Resize** | Always (saves cost) |
