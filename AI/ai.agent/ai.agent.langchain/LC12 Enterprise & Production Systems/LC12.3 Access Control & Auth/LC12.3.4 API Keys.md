| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.3.4.1 Key Generation** | Creation | Generate secure API keys | Use cryptographically secure random. |
| **LC12.3.4.2 Key Storage** | Security | Hash keys before storing | Never store plaintext keys. |
| **LC12.3.4.3 Key Rotation** | Maintenance | Regularly rotate keys | Support multiple active keys. |
| **LC12.3.4.4 Scoped Keys** | Permissions | Limit key permissions | Keys can have restricted access. |
| **LC12.3.4.5 Rate Limiting** | Protection | Limit requests per key | Prevent abuse. |

# API Keys: Authentication for Programmatic Access

Managing API keys for LangChain applications.

```python
import secrets
import hashlib

class APIKeyService:
    def generate_key(self, user_id: str, name: str) -> str:
        # Generate key
        key = f"lc_{secrets.token_urlsafe(32)}"
        
        # Hash for storage
        key_hash = hashlib.sha256(key.encode()).hexdigest()
        
        # Store hash
        db.execute(
            "INSERT INTO api_keys (user_id, key_hash, name) VALUES (%s, %s, %s)",
            (user_id, key_hash, name)
        )
        
        # Return key once (never shown again)
        return key
    
    def validate_key(self, key: str) -> dict:
        key_hash = hashlib.sha256(key.encode()).hexdigest()
        return db.query("SELECT * FROM api_keys WHERE key_hash = %s", (key_hash,)).fetchone()

# Middleware
@app.middleware("http")
async def api_key_auth(request, call_next):
    api_key = request.headers.get("X-API-Key")
    
    if api_key:
        key_data = api_key_service.validate_key(api_key)
        if key_data:
            request.state.user_id = key_data["user_id"]
    
    return await call_next(request)
```

**Quick Ref:** Generate once, hash before storing, validate on each request, support rotation.
