| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.3.6.1 JWT Structure** | Format | Header, Payload, Signature | Three parts separated by dots. |
| **LC12.3.6.2 Claims** | Data | Standard and custom claims | Payload contains user data. |
| **LC12.3.6.3 Validation** | Security | Verify signature and expiry | Always validate before trusting. |
| **LC12.3.6.4 Signing** | Security | HS256, RS256 algorithms | Sign tokens to prevent tampering. |
| **LC12.3.6.5 Best Practices** | Security | Short expiry, refresh tokens | Keep tokens short-lived. |

# JWT: JSON Web Tokens

Using JWTs for stateless authentication.

```python
import jwt
from datetime import datetime, timedelta

SECRET_KEY = "your-secret-key"

def generate_jwt(user_id: str, tenant_id: str) -> str:
    payload = {
        "sub": user_id,  # Subject (user ID)
        "tenant_id": tenant_id,
        "iat": datetime.utcnow(),  # Issued at
        "exp": datetime.utcnow() + timedelta(hours=24),  # Expiration
        "roles": ["user"]
    }
    
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")

def validate_jwt(token: str) -> dict:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        raise AuthError("Token expired")
    except jwt.InvalidTokenError:
        raise AuthError("Invalid token")

# Middleware
@app.middleware("http")
async def jwt_auth(request, call_next):
    auth_header = request.headers.get("Authorization", "")
    
    if auth_header.startswith("Bearer "):
        token = auth_header[7:]
        try:
            payload = validate_jwt(token)
            request.state.user_id = payload["sub"]
            request.state.tenant_id = payload["tenant_id"]
        except AuthError:
            return JSONResponse({"error": "Unauthorized"}, status_code=401)
    
    return await call_next(request)
```

**Quick Ref:** JWT = header.payload.signature, validate signature and expiry, use for stateless auth.
