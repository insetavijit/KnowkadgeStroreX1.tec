| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.3.2.1 Permission Model** | Design | Resources, actions, policies | Define what users can do. |
| **LC12.3.2.2 Checking Permissions** | Runtime | Verify access before action | Always check before executing. |
| **LC12.3.2.3 Resource-Based** | Pattern | Permissions tied to resources | Own a conversation = can access. |
| **LC12.3.2.4 ABAC** | Advanced | Attribute-based access control | Use attributes to determine access. |
| **LC12.3.2.5 Deny by Default** | Principle | Explicit allow required | Default to no access. |

# Authorization: Controlling Access

Implementing permission checks and access control.

---

## 1. Permission Model

```python
from enum import Enum

class Permission(Enum):
    READ_CONVERSATION = "conversations:read"
    WRITE_CONVERSATION = "conversations:write"
    DELETE_CONVERSATION = "conversations:delete"
    ADMIN_ACCESS = "admin:*"

class AuthorizationService:
    def has_permission(self, user_id: str, permission: Permission, resource_id: str = None) -> bool:
        user_permissions = self.get_user_permissions(user_id)
        
        # Check direct permission
        if permission.value in user_permissions:
            return True
        
        # Check wildcard permissions
        if f"{permission.value.split(':')[0]}:*" in user_permissions:
            return True
        
        # Check resource-specific permission
        if resource_id:
            return self.has_resource_permission(user_id, resource_id, permission)
        
        return False
```

---

## 2. Decorator Pattern

```python
from functools import wraps

def require_permission(permission: Permission):
    def decorator(f):
        @wraps(f)
        async def wrapper(*args, **kwargs):
            user_id = g.user_id  # From auth middleware
            
            if not auth_service.has_permission(user_id, permission):
                abort(403, "Permission denied")
            
            return await f(*args, **kwargs)
        return wrapper
    return decorator

# Usage
@app.get("/conversations/{conv_id}")
@require_permission(Permission.READ_CONVERSATION)
async def get_conversation(conv_id: str):
    return conversation_service.get(conv_id)
```

---

## 3. Resource-Based Authorization

```python
class ResourceAuth:
    def can_access(self, user_id: str, resource: dict, action: str) -> bool:
        # Owner can do anything
        if resource.get("owner_id") == user_id:
            return True
        
        # Check shared access
        if action == "read" and user_id in resource.get("shared_with", []):
            return True
        
        # Check team access
        user_teams = self.get_user_teams(user_id)
        resource_team = resource.get("team_id")
        if resource_team in user_teams:
            return True
        
        return False

@app.get("/conversations/{conv_id}")
async def get_conversation(conv_id: str):
    conv = conversation_service.get(conv_id)
    
    if not resource_auth.can_access(g.user_id, conv, "read"):
        abort(403)
    
    return conv
```

---

## 4. Attribute-Based Access Control (ABAC)

```python
class ABACPolicy:
    def evaluate(self, subject: dict, resource: dict, action: str, environment: dict) -> bool:
        # Example policy: Users can read conversations in their department
        if (action == "read" and
            subject.get("department") == resource.get("department")):
            return True
        
        # Managers can access all in their department
        if (subject.get("role") == "manager" and
            subject.get("department") == resource.get("department")):
            return True
        
        # Business hours only for non-admin
        if subject.get("role") != "admin":
            hour = environment.get("hour", 12)
            if hour < 9 or hour > 17:
                return False
        
        return False

# Usage
policy_result = abac.evaluate(
    subject={"user_id": user_id, "role": "employee", "department": "sales"},
    resource={"conversation_id": conv_id, "department": "sales"},
    action="read",
    environment={"hour": datetime.now().hour}
)
```

---

## 5. Complete Authorization System

```python
class AuthorizationMiddleware:
    async def check_access(self, request, call_next):
        user_id = request.state.user_id
        
        # Extract resource from request
        resource_type = self.get_resource_type(request.url.path)
        resource_id = self.get_resource_id(request.url.path)
        action = self.action_from_method(request.method)
        
        # Load resource
        resource = await self.load_resource(resource_type, resource_id)
        
        # Check permission
        if not self.authorize(user_id, resource, action):
            return JSONResponse({"error": "Forbidden"}, status_code=403)
        
        return await call_next(request)
    
    def authorize(self, user_id: str, resource: dict, action: str) -> bool:
        # 1. Check RBAC
        if rbac.has_permission(user_id, f"{resource['type']}:{action}"):
            return True
        
        # 2. Check ownership
        if resource.get("owner_id") == user_id:
            return True
        
        # 3. Check ABAC policy
        subject = user_service.get(user_id)
        return abac.evaluate(subject, resource, action, {"timestamp": datetime.now()})
```

---

## Quick Reference

| Model | When to Use |
|-------|-------------|
| **RBAC** | Standard permissions |
| **Resource-based** | Ownership patterns |
| **ABAC** | Complex, contextual rules |
