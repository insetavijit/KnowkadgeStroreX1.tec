| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.3.1.1 Login Flows** | Process | Username/password, SSO, OAuth | Multiple auth methods supported. |
| **LC12.3.1.2 Session Management** | State | Cookies, tokens, session store | Manage authenticated sessions. |
| **LC12.3.1.3 Password Policies** | Security | Strong passwords, rotation | Enforce password requirements. |
| **LC12.3.1.4 MFA** | Security | Two-factor authentication | Require second factor for auth. |
| **LC12.3.1.5 Account Lockout** | Protection | Prevent brute force | Lock after failed attempts. |

# Authentication: Verifying User Identity

Implementing secure user authentication for LangChain applications.

---

## 1. Basic Authentication

```python
from flask import Flask, request, session
from werkzeug.security import check_password_hash
import jwt

@app.post("/auth/login")
async def login():
    data = await request.json()
    user = await user_service.get_by_email(data["email"])
    
    if not user or not check_password_hash(user.password_hash, data["password"]):
        return {"error": "Invalid credentials"}, 401
    
    # Generate JWT
    token = jwt.encode({
        "sub": user.id,
        "tenant_id": user.tenant_id,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }, SECRET_KEY)
    
    return {"token": token, "user": user.to_dict()}
```

---

## 2. Session Management

```python
from redis import Redis

class SessionManager:
    def __init__(self, redis: Redis):
        self.redis = redis
    
    def create_session(self, user_id: str) -> str:
        session_id = secrets.token_urlsafe(32)
        
        self.redis.setex(
            f"session:{session_id}",
            3600,  # 1 hour
            json.dumps({"user_id": user_id})
        )
        
        return session_id
    
    def get_session(self, session_id: str) -> dict:
        data = self.redis.get(f"session:{session_id}")
        return json.loads(data) if data else None
    
    def refresh_session(self, session_id: str):
        self.redis.expire(f"session:{session_id}", 3600)
```

---

## 3. MFA Implementation

```python
import pyotp

class MFAService:
    def setup_mfa(self, user_id: str) -> dict:
        secret = pyotp.random_base32()
        
        # Save secret
        await user_service.update(user_id, {"mfa_secret": secret})
        
        # Generate QR code URL
        totp = pyotp.TOTP(secret)
        uri = totp.provisioning_uri(
            name=user.email,
            issuer_name="LangChain App"
        )
        
        return {"secret": secret, "qr_uri": uri}
    
    def verify_mfa(self, user_id: str, code: str) -> bool:
        user = await user_service.get(user_id)
        totp = pyotp.TOTP(user.mfa_secret)
        return totp.verify(code, valid_window=1)

@app.post("/auth/mfa/verify")
async def verify_mfa():
    data = await request.json()
    
    if mfa_service.verify_mfa(data["user_id"], data["code"]):
        token = generate_token(data["user_id"])
        return {"token": token}
    
    return {"error": "Invalid code"}, 401
```

---

## 4. Account Lockout

```python
class AccountLockout:
    MAX_ATTEMPTS = 5
    LOCKOUT_DURATION = 900  # 15 minutes
    
    def record_failed_attempt(self, email: str):
        key = f"login_attempts:{email}"
        attempts = int(redis.get(key) or 0)
        
        redis.incr(key)
        redis.expire(key, 900)
        
        if attempts + 1 >= self.MAX_ATTEMPTS:
            redis.setex(f"locked:{email}", self.LOCKOUT_DURATION, "1")
    
    def is_locked(self, email: str) -> bool:
        return redis.exists(f"locked:{email}")
    
    def unlock(self, email: str):
        redis.delete(f"locked:{email}")
        redis.delete(f"login_attempts:{email}")
```

---

## 5. Complete Auth Flow

```python
@app.post("/auth/login")
async def login():
    data = await request.json()
    email = data["email"]
    
    # Check lockout
    if lockout.is_locked(email):
        return {"error": "Account locked. Try again later."}, 429
    
    # Verify credentials
    user = await user_service.get_by_email(email)
    if not user or not check_password_hash(user.password_hash, data["password"]):
        lockout.record_failed_attempt(email)
        return {"error": "Invalid credentials"}, 401
    
    # Check MFA
    if user.mfa_enabled:
        if not data.get("mfa_code"):
            return {"requires_mfa": True}, 200
        
        if not mfa_service.verify_mfa(user.id, data["mfa_code"]):
            return {"error": "Invalid MFA code"}, 401
    
    # Generate token
    token = generate_token(user.id, user.tenant_id)
    
    # Clear failed attempts
    lockout.unlock(email)
    
    return {"token": token, "user": user.to_dict()}
```

---

## Quick Reference

| Method | Security | Complexity |
|--------|----------|------------|
| **Basic Auth** | Low | Low |
| **JWT** | Medium | Medium |
| **OAuth** | High | High |
| **MFA** | Very High | Medium |
