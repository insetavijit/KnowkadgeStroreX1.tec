| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.3.8.1 Runtime Checks** | Enforcement | Check at execution time | Validate permission before action. |
| **LC12.3.8.2 Decorator Pattern** | Implementation | Wrap functions with checks | Reusable permission decorators. |
| **LC12.3.8.3 Policy Engine** | Advanced | Centralized policy evaluation | Single source of truth for permissions. |
| **LC12.3.8.4 Fail-Safe** | Security | Deny by default | Default to no access. |
| **LC12.3.8.5 Performance** | Optimization | Cache permission results | Don't check repeatedly. |

# Permission Checking: Enforcing Access Control

Runtime permission validation patterns.

```python
from functools import wraps, lru_cache

class PermissionChecker:
    def __init__(self):
        self.cache = {}
    
    @lru_cache(maxsize=1000)
    def check(self, user_id: str, permission: str, resource_id: str = None) -> bool:
        # RBAC check
        if rbac_service.has_permission(user_id, permission):
            return True
        
        # Resource ownership check
        if resource_id:
            resource = resource_service.get(resource_id)
            if resource.owner_id == user_id:
                return True
        
        # Default deny
        return False

def require_permission(permission: str, resource_param: str = None):
    """Decorator for permission checking."""
    def decorator(f):
        @wraps(f)
        async def wrapper(*args, **kwargs):
            user_id = g.user_id
            
            # Extract resource ID if specified
            resource_id = kwargs.get(resource_param) if resource_param else None
            
            if not permission_checker.check(user_id, permission, resource_id):
                logger.warning(f"Permission denied: {user_id} attempted {permission}")
                abort(403, "Permission denied")
            
            return await f(*args, **kwargs)
        return wrapper
    return decorator

# Usage
@app.delete("/conversations/{conv_id}")
@require_permission("conversations:delete", resource_param="conv_id")
async def delete_conversation(conv_id: str):
    conversation_service.delete(conv_id)
    return {"status": "deleted"}

# Batch checking
def check_bulk_permissions(user_id: str, actions: list[dict]) -> list[bool]:
    return [permission_checker.check(user_id, action["permission"], action.get("resource_id")) 
            for action in actions]
```

**Quick Ref:** Always check permissions at runtime, use decorators for reusability, cache results for performance.
