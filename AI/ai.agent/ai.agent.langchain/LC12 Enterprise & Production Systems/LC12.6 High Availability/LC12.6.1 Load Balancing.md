| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.6.1-8** | HA Patterns | Load Balancing, Failover, Redundancy, Health Checks, Circuit Breakers, DR, Geo-distribution, Uptime SLAs | High availability architecture patterns. |

# High Availability: Load Balancing / Failover / Redundancy / Health Checks / Circuit Breakers / Disaster Recovery / Geographic Distribution / Uptime SLAs

```python
# Load Balancing
from fastapi import FastAPI
app = FastAPI()

@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.utcnow()}

# Circuit Breaker
from circuitbreaker import circuit

@circuit(failure_threshold=5, recovery_timeout=60)
async def call_llm_api(prompt: str):
    return await llm.ainvoke(prompt)

# Failover Pattern
class FailoverLLM:
    def __init__(self):
        self.primary = ChatOpenAI(model="gpt-4o")
        self.fallback = ChatOpenAI(model="gpt-4o-mini")
    
    async def invoke(self, prompt: str):
        try:
            return await self.primary.ainvoke(prompt)
        except Exception:
            logger.warning("Primary LLM failed, using fallback")
            return await self.fallback.ainvoke(prompt)

# Kubernetes Deployment with HA
"""
apiVersion: apps/v1
kind: Deployment
metadata:
  name: langchain-api
spec:
  replicas: 3  # Multiple instances
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
"""
```

**Quick Ref:** Redundancy + health checks + failover + load balancing = high availability.
