| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
|---|---|---|---|
| **LC12.1.7.1 API Gateway Pattern** | Entry point | Single entry for all services | Gateway routes and transforms requests. |
| **LC12.1.7.2 Backend for Frontend** | Adaptation | Service per client type | Tailor backend to frontend needs. |
| **LC12.1.7.3 Saga Pattern** | Transactions | Distributed transactions | Compensate on failure in dist systems. |
| **LC12.1.7.4 Strangler Fig** | Migration | Gradual system replacement | Incrementally replace legacy. |
| **LC12.1.7.5 Bulkhead Pattern** | Isolation | Isolate failures | Prevent cascade failures. |

# System Design Patterns: Proven Architectures

Common patterns for enterprise LangChain systems.

---

## 1. API Gateway Pattern

```python
# FastAPI as API Gateway
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse

app = FastAPI()

# Route to appropriate service
@app.post("/api/v1/{service}/{operation}")
async def gateway(service: str, operation: str, request: dict):
    if service == "query":
        return await query_service.handle(operation, request)
    elif service == "document":
        return await document_service.handle(operation, request)
    else:
        raise HTTPException(404, "Service not found")

# Add cross-cutting concerns
@app.middleware("http")
async def add_auth(request, call_next):
    # Authentication
    token = request.headers.get("Authorization")
    if not validate_token(token):
        return JSONResponse({"error": "Unauthorized"}, status_code=401)
    
    # Logging
    logger.info(f"Request: {request.url}")
    
    response = await call_next(request)
    return response
```

---

## 2. Backend for Frontend (BFF)

```python
# Mobile BFF - optimized for mobile clients
class MobileBFF:
    async def get_conversation(self, conversation_id: str):
        # Lightweight response for mobile
        return {
            "messages": await self.get_latest_messages(conversation_id, limit=20),
            "summary": await self.get_summary(conversation_id)
        }

# Web BFF - richer for web clients  
class WebBFF:
    async def get_conversation(self, conversation_id: str):
        # Full response for web
        return {
            "messages": await self.get_all_messages(conversation_id),
            "participants": await self.get_participants(conversation_id),
            "metadata": await self.get_metadata(conversation_id),
            "related": await self.get_related_conversations(conversation_id)
        }
```

---

## 3. Saga Pattern

```python
# Distributed transaction across services
class DocumentProcessingSaga:
    async def execute(self, document_id: str):
        try:
            # Step 1: Load document
            doc = await document_service.load(document_id)
            
            # Step 2: Extract text
            text = await extraction_service.extract(doc)
            
            # Step 3: Embed and store
            await vector_service.store(text)
            
            # Step 4: Update status
            await status_service.mark_complete(document_id)
            
        except Exception as e:
            # Compensate (undo previous steps)
            await self.compensate(document_id, e)
    
    async def compensate(self, document_id: str, error: Exception):
        # Rollback in reverse order
        await vector_service.delete(document_id)
        await extraction_service.cleanup(document_id)
        await document_service.mark_failed(document_id, str(error))
```

---

## 4. Strangler Fig Pattern

```python
# Gradually replace legacy system
class HybridRouter:
    def __init__(self, legacy_system, new_system):
        self.legacy = legacy_system
        self.new_system = new_system
        self.migration_percentage = 10  # Start with 10%
    
    async def route_query(self, query: str):
        # Decide which system to use
        if self.should_use_new_system():
            try:
                return await self.new_system.process(query)
            except Exception as e:
                logger.error(f"New system failed: {e}")
                return await self.legacy.process(query)  # Fallback
        else:
            return await self.legacy.process(query)
    
    def should_use_new_system(self) -> bool:
        return random.random() < (self.migration_percentage / 100)

# Gradually increase migration_percentage: 10% → 25% → 50% → 100%
```

---

## 5. Bulkhead Pattern

```python
# Isolate failures with separate thread pools
from concurrent.futures import ThreadPoolExecutor

class BulkheadService:
    def __init__(self):
        # Separate pools for different operations
        self.llm_pool = ThreadPoolExecutor(max_workers=5, thread_name_prefix="llm")
        self.db_pool = ThreadPoolExecutor(max_workers=10, thread_name_prefix="db")
        self.cache_pool = ThreadPoolExecutor(max_workers=3, thread_name_prefix="cache")
    
    async def query(self, text: str):
        # LLM failure won't exhaust DB pool
        llm_future = self.llm_pool.submit(self.call_llm, text)
        
        # DB operation in separate pool
        docs_future = self.db_pool.submit(self.get_docs, text)
        
        return await asyncio.gather(llm_future, docs_future)

# If LLM service is slow/down, DB operations still work
```

---

## Quick Reference

| Pattern | Solves |
|---------|--------|
| **API Gateway** | Single entry, auth, routing |
| **BFF** | Client-specific needs |
| **Saga** | Distributed transactions |
| **Strangler Fig** | Safe migration |
| **Bulkhead** | Failure isolation |
