| **Subtopic**                                   | **Focus & Purpose**                     | **Key Concepts / Details**                                                    | **One-Line Recall**                                             |
| ---------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **LC12.1.4.1 DDD in LangChain**                | Application                             | Applying DDD to LLM applications                                              | DDD helps structure complex LLM apps.                           |
| **LC12.1.4.2 Bounded Contexts**                | Boundaries                              | Defining context boundaries                                                   | Each context has its own language/model.                        |
| **LC12.1.4.3 Aggregates**                      | Pattern                                 | Modeling aggregates                                                           | Aggregates are consistency boundaries.                          |
| **LC12.1.4.4 Domain Events**                   | Events                                  | Domain-driven events                                                          | Events capture domain changes.                                  |
| **LC12.1.4.5 Repository Pattern**              | Data                                    | Data access abstraction                                                       | Repositories abstract persistence.                              |

# Domain-Driven Design: Structuring LLM Applications

Applying DDD principles to LangChain applications.

---

## 1. DDD for LangChain

**Core Concepts**:
- **Domain**: The business problem (e.g., customer support)
- **Entities**: Objects with identity (User, Conversation, Document)
- **Value Objects**: Immutable values (Query, Message, Embedding)
- **Aggregates**: Consistency boundaries (Conversation aggregate)

---

## 2. Bounded Contexts

```python
# Customer Support Context
class SupportConversation:
    """Bounded context: Customer Support"""
    def __init__(self, customer_id: str):
        self.customer_id = customer_id
        self.messages = []
        self.status = "open"
        self.assigned_agent = None
    
    def add_message(self, message: Message):
        self.messages.append(message)
    
    def escalate(self):
        self.status = "escalated"
        # Publish domain event
        publish(ConversationEscalated(self.id))

# Knowledge Base Context
class DocumentRepository:
    """Bounded context: Knowledge Management"""
    def __init__(self):
        self.vectorstore = Chroma(...)
    
    def add_document(self, doc: Document):
        # This context's logic
        chunks = self.split_document(doc)
        self.vectorstore.add_documents(chunks)
    
    def search(self, query: str) -> list[Document]:
        return self.vectorstore.similarity_search(query)
```

---

## 3. Aggregates

```python
from dataclasses import dataclass
from typing import List

@dataclass
class Message:
    content: str
    role: str
    timestamp: datetime

class ConversationAggregate:
    """
    Aggregate Root: Conversation
    Ensures consistency within conversation boundary
    """
    def __init__(self, conversation_id: str):
        self.id = conversation_id
        self.messages: List[Message] = []
        self._events: List[DomainEvent] = []
    
    def add_message(self, content: str, role: str):
        """Business logic within aggregate."""
        # Validation
        if not content.strip():
            raise ValueError("Message cannot be empty")
        
        # Add message
        message = Message(content, role, datetime.now())
        self.messages.append(message)
        
        # Record domain event
        self._events.append(MessageAdded(self.id, message))
    
    def generate_response(self, llm):
        """Generate response with context."""
        if not self.messages:
            raise ValueError("No messages to respond to")
        
        response = llm.invoke(self.messages)
        self.add_message(response.content, "assistant")
        
        return response
    
    @property
    def events(self):
        """Retrieve and clear events."""
        events = self._events.copy()
        self._events.clear()
        return events
```

---

## 4. Domain Events

```python
from abc import ABC
from dataclasses import dataclass

class DomainEvent(ABC):
    """Base domain event."""
    timestamp: datetime

@dataclass
class MessageAdded(DomainEvent):
    conversation_id: str
    message: Message
    timestamp: datetime = None
    
    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = datetime.now()

@dataclass
class ConversationEscalated(DomainEvent):
    conversation_id: str
    reason: str
    timestamp: datetime = None

# Event Handler
class MessageAddedHandler:
    def handle(self, event: MessageAdded):
        # Side effects
        notify_participants(event.conversation_id)
        update_read_model(event)
        check_sentiment(event.message)
```

---

## 5. Repository Pattern

```python
from abc import ABC, abstractmethod

class ConversationRepository(ABC):
    """Abstract repository."""
    
    @abstractmethod
    def get(self, conversation_id: str) -> ConversationAggregate:
        pass
    
    @abstractmethod
    def save(self, conversation: ConversationAggregate):
        pass

class PostgresConversationRepository(ConversationRepository):
    """Concrete implementation."""
    
    def __init__(self, db_connection):
        self.db = db_connection
    
    def get(self, conversation_id: str) -> ConversationAggregate:
        # Load from DB
        rows = self.db.execute(
            "SELECT * FROM messages WHERE conversation_id = %s",
            (conversation_id,)
        )
        
        conversation = ConversationAggregate(conversation_id)
        for row in rows:
            conversation.messages.append(Message(**row))
        
        return conversation
    
    def save(self, conversation: ConversationAggregate):
        # Save to DB
        for message in conversation.messages:
            self.db.execute(
                "INSERT INTO messages ...",
                message
            )
        
        # Publish events
        for event in conversation.events:
            self.event_bus.publish(event)
```

---

## Quick Reference

| DDD Concept | LangChain Example |
|-------------|-------------------|
| **Entity** | Conversation, User |
| **Value Object** | Message, Query |
| **Aggregate** | Conversation + Messages |
| **Repository** | ConversationRepository |
| **Domain Event** | MessageAdded, EscalatedSubject: Event-Driven Chain Execution has begun.

Due to my response length limits, I'll continue creating the remaining 60+ files systematically. Let me batch several files together to complete LC12 efficiently.

