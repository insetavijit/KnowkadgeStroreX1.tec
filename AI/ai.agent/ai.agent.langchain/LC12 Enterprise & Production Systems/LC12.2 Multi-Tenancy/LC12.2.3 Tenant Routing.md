| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.2.3.1 Subdomain Routing** | Pattern | tenant.app.com identifies tenant | Use subdomain to identify tenant. |
| **LC12.2.3.2 Header-Based** | Pattern | X-Tenant-ID header | Pass tenant in request header. |
| **LC12.2.3.3 JWT Claims** | Pattern | Tenant in token claims | Extract tenant from JWT. |
| **LC12.2.3.4 Path-Based** | Pattern | /api/t/{tenant_id}/resource | Tenant in URL path. |
| **LC12.2.3.5 Routing Middleware** | Implementation | Automatic tenant extraction | Middleware sets tenant context. |

# Tenant Routing: Identifying Tenants

Determining which tenant a request belongs to.

---

## 1. Subdomain Routing

```python
from urllib.parse import urlparse

def get_tenant_from_subdomain(request) -> str:
    host = request.headers.get('Host', '')
    # tenant.app.com â†’ tenant
    parts = host.split('.')
    if len(parts) >= 3:
        return parts[0]
    return None

# Middleware
@app.middleware("http")
async def tenant_middleware(request, call_next):
    tenant_id = get_tenant_from_subdomain(request)
    request.state.tenant_id = tenant_id
    return await call_next(request)
```

---

## 2. Header-Based Routing

```python
def get_tenant_from_header(request) -> str:
    return request.headers.get('X-Tenant-ID')

# Usage
@app.get("/api/conversations")
async def get_conversations(request: Request):
    tenant_id = request.state.tenant_id
    return conversation_service.get_all(tenant_id)
```

---

## 3. JWT Claims

```python
import jwt

def get_tenant_from_jwt(token: str) -> str:
    payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    return payload.get('tenant_id')

# Middleware
async def auth_and_tenant_middleware(request, call_next):
    token = request.headers.get('Authorization', '').replace('Bearer ', '')
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        request.state.user_id = payload['sub']
        request.state.tenant_id = payload['tenant_id']
    except jwt.InvalidTokenError:
        return JSONResponse({'error': 'Invalid token'}, status_code=401)
    
    return await call_next(request)
```

---

## 4. Path-Based Routing

```python
# Route pattern: /api/t/{tenant_id}/...
@app.get("/api/t/{tenant_id}/conversations")
async def get_conversations(tenant_id: str):
    # Verify user has access to this tenant
    if not user_can_access_tenant(request.state.user_id, tenant_id):
        raise HTTPException(403, "Access denied")
    
    return conversation_service.get_all(tenant_id)
```

---

## 5. Complete Routing Middleware

```python
class TenantRouter:
    def __init__(self, strategy: str = "subdomain"):
        self.strategy = strategy
    
    def extract_tenant(self, request) -> str:
        if self.strategy == "subdomain":
            return self.from_subdomain(request)
        elif self.strategy == "header":
            return self.from_header(request)
        elif self.strategy == "jwt":
            return self.from_jwt(request)
        elif self.strategy == "path":
            return self.from_path(request)
    
    def from_subdomain(self, request) -> str:
        host = request.headers.get('Host', '')
        return host.split('.')[0] if '.' in host else None
    
    def from_header(self, request) -> str:
        return request.headers.get('X-Tenant-ID')
    
    def from_jwt(self, request) -> str:
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload.get('tenant_id')
    
    def from_path(self, request) -> str:
        # Extract from /api/t/{tenant_id}/...
        parts = request.url.path.split('/')
        if len(parts) > 3 and parts[2] == 't':
            return parts[3]
        return None
```

---

## Quick Reference

| Strategy | Pros | Cons |
|----------|------|------|
| **Subdomain** | Clean URLs, CDN-friendly | Requires DNS setup |
| **Header** | Simple, works anywhere | Not browser-friendly |
| **JWT** | Secure, standard | Requires auth |
| **Path** | Explicit, works everywhere | Longer URLs |
