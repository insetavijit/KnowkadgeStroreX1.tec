| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.2.4.1 Storage Separation** | Architecture | Separate storage per tenant | Physical or logical separation. |
| **LC12.2.4.2 Backup Isolation** | Recovery | Tenant-specific backups | Each tenant can restore independently. |
| **LC12.2.4.3 Encryption** | Security | Per-tenant encryption keys | Different keys per tenant. |
| **LC12.2.4.4 Data Residency** | Compliance | Store data in required regions | Meet geographic requirements. |
| **LC12.2.4.5 Cross-Tenant Prevention** | Security | Prevent data leakage | Validate tenant context everywhere. |

# Data Isolation: Securing Tenant Storage

Keeping tenant data completely separate and secure.

---

## 1. Storage Strategies

```python
# Strategy 1: Database per tenant
class TenantDatabaseManager:
    def get_db(self, tenant_id: str):
        return create_engine(f"postgresql:///{tenant_id}_db")

# Strategy 2: Schema per tenant
class TenantSchemaManager:
    def get_session(self, tenant_id: str):
        engine = create_engine(DATABASE_URL)
        connection = engine.connect()
        connection.execute(text(f"SET search_path TO {tenant_id}"))
        return Session(bind=connection)

# Strategy 3: Shared with tenant_id column
class SharedDatabaseManager:
    def query(self, tenant_id: str, table: str):
        return db.execute(
            f"SELECT * FROM {table} WHERE tenant_id = %s",
            (tenant_id,)
        )
```

---

## 2. Backup Isolation

```python
# Per-tenant backup strategy
import boto3

class TenantBackupManager:
    def backup_tenant(self, tenant_id: str):
        # Backup to tenant-specific S3 prefix
        s3 = boto3.client('s3')
        
        # Export tenant database
        dump = pg_dump(tenant_id)
        
        # Upload to isolated location
        s3.put_object(
            Bucket='backups',
            Key=f'tenants/{tenant_id}/backup_{datetime.now().isoformat()}.sql',
            Body=dump
        )
    
    def restore_tenant(self, tenant_id: str, backup_id: str):
        # Restore only this tenant
        s3 = boto3.client('s3')
        backup = s3.get_object(
            Bucket='backups',
            Key=f'tenants/{tenant_id}/{backup_id}'
        )
        pg_restore(tenant_id, backup['Body'].read())
```

---

## 3. Per-Tenant Encryption

```python
from cryptography.fernet import Fernet

class TenantEncryption:
    def __init__(self):
        self.keys = {}  # tenant_id -> encryption_key
    
    def get_key(self, tenant_id: str) -> bytes:
        if tenant_id not in self.keys:
            # Load from secure key store
            self.keys[tenant_id] = self.load_key(tenant_id)
        return self.keys[tenant_id]
    
    def encrypt(self, tenant_id: str, data: str) -> bytes:
        key = self.get_key(tenant_id)
        f = Fernet(key)
        return f.encrypt(data.encode())
    
    def decrypt(self, tenant_id: str, encrypted: bytes) -> str:
        key = self.get_key(tenant_id)
        f = Fernet(key)
        return f.decrypt(encrypted).decode()

# Usage in vector store
def add_document(tenant_id: str, doc: str):
    encrypted = encryption.encrypt(tenant_id, doc)
    vectorstore.add_documents([
        Document(
            page_content=encrypted,
            metadata={"tenant_id": tenant_id, "encrypted": True}
        )
    ])
```

---

## 4. Data Residency Compliance

```python
class DataResidencyManager:
    REGION_ENDPOINTS = {
        "EU": "https://eu.api.example.com",
        "US": "https://us.api.example.com",
        "ASIA": "https://asia.api.example.com"
    }
    
    def get_endpoint(self, tenant_id: str) -> str:
        config = config_service.get_config(tenant_id)
        region = config.data_residency
        return self.REGION_ENDPOINTS[region]
    
    def validate_storage_location(self, tenant_id: str, resource_region: str) -> bool:
        config = config_service.get_config(tenant_id)
        required_region = config.data_residency
        
        if resource_region != required_region:
            raise ComplianceError(
                f"Tenant {tenant_id} requires {required_region}, "
                f"but resource is in {resource_region}"
            )
        return True
```

---

## 5. Cross-Tenant Access Prevention

```python
class TenantAccessGuard:
    """Decorator to enforce tenant access control."""
    
    def require_tenant_access(self, resource_tenant_id: str):
        def decorator(f):
            @wraps(f)
            def wrapper(*args, **kwargs):
                request_tenant_id = g.tenant_id  # From middleware
                
                if request_tenant_id != resource_tenant_id:
                    logger.warning(
                        f"Cross-tenant access attempt: "
                        f"{request_tenant_id} tried to access {resource_tenant_id}"
                    )
                    abort(403, "Access denied")
                
                return f(*args, **kwargs)
            return wrapper
        return decorator

# Usage
@app.get("/conversations/{conversation_id}")
@require_tenant
def get_conversation(tenant_id: str, conversation_id: str):
    conv = conversation_repo.get(conversation_id)
    
    # Double-check tenant ownership
    if conv.tenant_id != tenant_id:
        abort(403)
    
    return conv
```

---

## Quick Reference

| Isolation Level | Security  | Cost | Complexity |
|-----------------|-----------|------|------------|
| **Separate DB** | Highest   | High | High |
| **Schema** | High      | Medium | Medium |
| **Row-level** | Medium    | Low | Low |
| **Encrypted** | Very High | Medium | Medium |
