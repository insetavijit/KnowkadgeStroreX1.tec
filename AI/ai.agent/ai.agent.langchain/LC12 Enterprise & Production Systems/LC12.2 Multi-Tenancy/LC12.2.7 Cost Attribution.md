| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.2.7.1 Token Tracking** | Monitoring | Count tokens per tenant | Track LLM API usage by tenant. |
| **LC12.2.7.2 Cost Calculation** | Finance | Calculate costs per tenant | Convert tokens to dollars. |
| **LC12.2.7.3 Chargeback Systems** | Billing | Internal billing mechanisms | Charge departments for usage. |
| **LC12.2.7.4 Usage Reporting** | Analytics | Cost dashboards and reports | Visualize tenant costs. |
| **LC12.2.7.5 Budget Alerts** | Monitoring | Notify on budget overruns | Alert when tenant exceeds budget. |

# Cost Attribution: Tracking Tenant Spending

Attributing LLM costs to individual tenants.

---

## 1. Token Tracking

```python
class TokenTracker:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def track_usage(self, tenant_id: str, tokens: int, model: str):
        # Daily usage key
        date = datetime.now().strftime("%Y-%m-%d")
        key = f"usage:{tenant_id}:{date}:{model}"
        
        self.redis.hincrby(key, "tokens", tokens)
        self.redis.expire(key, 86400 * 90)  # 90 days retention
    
    async def get_usage(self, tenant_id: str, start_date: str, end_date: str):
        # Aggregate usage
        total = 0
        current = datetime.strptime(start_date, "%Y-%m-%d")
        end = datetime.strptime(end_date, "%Y-%m-%d")
        
        while current <= end:
            date_str = current.strftime("%Y-%m-%d")
            keys = self.redis.keys(f"usage:{tenant_id}:{date_str}:*")
            for key in keys:
                total += int(self.redis.hget(key, "tokens") or 0)
            current += timedelta(days=1)
        
        return total

# Wrap LLM to track tokens
class TrackedLLM:
    def __init__(self, llm, tenant_id: str, tracker: TokenTracker):
        self.llm = llm
        self.tenant_id = tenant_id
        self.tracker = tracker
    
    async def ainvoke(self, messages):
        response = await self.llm.ainvoke(messages)
        
        # Track tokens
        tokens = response.response_metadata.get("token_usage", {})
        total_tokens = tokens.get("total_tokens", 0)
        
        await self.tracker.track_usage(
            self.tenant_id,
            total_tokens,
            self.llm.model_name
        )
        
        return response
```

---

## 2. Cost Calculation

```python
PRICING = {
    "gpt-4o": {"input": 0.005 / 1000, "output": 0.015 / 1000},
    "gpt-4o-mini": {"input": 0.00015 / 1000, "output": 0.0006 / 1000},
    "claude-3": {"input": 0.003 / 1000, "output": 0.015 / 1000}
}

class CostCalculator:
    def calculate_cost(self, model: str, input_tokens: int, output_tokens: int) -> float:
        pricing = PRICING.get(model, PRICING["gpt-4o-mini"])
        
        cost = (
            input_tokens * pricing["input"] +
            output_tokens * pricing["output"]
        )
        
        return round(cost, 4)
    
    async def get_tenant_cost(self, tenant_id: str, month: str) -> dict:
        usage = await self.get_usage_breakdown(tenant_id, month)
        
        total_cost = 0
        breakdown = {}
        
        for model, tokens in usage.items():
            cost = self.calculate_cost(
                model,
                tokens["input"],
                tokens["output"]
            )
            breakdown[model] = cost
            total_cost += cost
        
        return {
            "tenant_id": tenant_id,
            "month": month,
            "total_cost": total_cost,
            "breakdown": breakdown
        }
```

---

## 3. Chargeback System

```python
class ChargebackSystem:
    async def generate_invoice(self, tenant_id: str, month: str) -> dict:
        cost_data = await cost_calculator.get_tenant_cost(tenant_id, month)
        
        invoice = {
            "invoice_id": generate_invoice_id(),
            "tenant_id": tenant_id,
            "period": month,
            "line_items": [
                {
                    "description": f"{model} API Usage",
                    "amount": cost
                }
                for model, cost in cost_data["breakdown"].items()
            ],
            "subtotal": cost_data["total_cost"],
            "tax": cost_data["total_cost"] * 0.10,  # 10% tax
            "total": cost_data["total_cost"] * 1.10,
            "due_date": self.calculate_due_date(month)
        }
        
        await self.save_invoice(invoice)
        return invoice
    
    async def send_invoice(self, invoice: dict):
        tenant = await tenant_service.get(invoice["tenant_id"])
        await email_service.send(
            to=tenant.billing_email,
            subject=f"Invoice for {invoice['period']}",
            body=render_invoice(invoice)
        )
```

---

## 4. Usage Dashboards

```python
@app.get("/api/admin/costs/dashboard")
async def cost_dashboard(start_date: str, end_date: str):
    tenants = await tenant_service.get_all()
    
    dashboard_data = []
    for tenant in tenants:
        cost = await cost_calculator.get_tenant_cost(
            tenant.id,
            start_date,
            end_date
        )
        dashboard_data.append({
            "tenant_name": tenant.name,
            "cost": cost["total_cost"],
            "token_usage": cost.get("total_tokens"),
            "trend": await get_cost_trend(tenant.id)
        })
    
    return {
        "total_cost": sum(d["cost"] for d in dashboard_data),
        "tenants": sorted(dashboard_data, key=lambda x: x["cost"], reverse=True)
    }
```

---

## 5. Budget Alerts

```python
class BudgetMonitor:
    async def check_budgets(self):
        """Run periodically to check tenant budgets."""
        tenants = await tenant_service.get_all()
        
        for tenant in tenants:
            config = await config_service.get_config(tenant.id)
            budget = config.monthly_budget
            
            if not budget:
                continue
            
            current_month = datetime.now().strftime("%Y-%m")
            cost = await cost_calculator.get_tenant_cost(tenant.id, current_month)
            
            usage_percent = (cost["total_cost"] / budget) * 100
            
            if usage_percent >= 90:
                await self.send_alert(
                    tenant,
                    f"Budget alert: {usage_percent:.0f}% used",
                    cost["total_cost"],
                    budget
                )
            
            if usage_percent >= 100:
                await self.enforce_limit(tenant.id)
    
    async def enforce_limit(self, tenant_id: str):
        # Stop processing for over-budget tenant
        await tenant_service.suspend(tenant_id, "Budget exceeded")
```

---

## Quick Reference

| Task | Tool |
|------|------|
| **Track** | Token counter + Redis |
| **Calculate** | Pricing table |
| **Bill** | Invoice generation |
| **Monitor** | Budget alerts |
