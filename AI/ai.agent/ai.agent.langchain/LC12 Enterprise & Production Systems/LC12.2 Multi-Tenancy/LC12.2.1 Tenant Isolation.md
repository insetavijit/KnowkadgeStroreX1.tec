| **Subtopic** | **Focus** | **Key Concepts** | **One-Line Recall** |
|---|---|---|---|
| **LC12.2.1.1 Data Isolation** | Security | Separate tenant data completely | Each tenant's data is isolated. |
| **LC12.2.1.2 Database Strategies** | Architecture | Per-tenant DB, shared schema, shared DB | Choose isolation level vs cost. |
| **LC12.2.1.3 Vector Store Isolation** | Embeddings | Tenant-specific collections | Filter by tenant_id in vector stores. |
| **LC12.2.1.4 Security Boundaries** | Protection | Preventing cross-tenant access | Enforce tenant checks everywhere. |
| **LC12.2.1.5 Compliance** | Regulation | Data residency, privacy | Tenants may have different requirements. |

# Tenant Isolation: Securing Multi-Tenant Data

Ensuring tenants cannot access each other's data.

---

## 1. Isolation Strategies

| Strategy | Isolation | Cost | Complexity |
|----------|-----------|------|------------|
| **Separate DB per tenant** | Highest | High | High |
| **Shared DB, schema per tenant** | High | Medium | Medium |
| **Shared DB + schema + tenant_id** | Medium | Low | Low |

---

## 2. Vector Store Isolation

```python
from lang chain_chroma import Chroma

class MultiTenantVectorStore:
    def __init__(self):
        # Shared vector store with tenant filtering
        self.vectorstore = Chroma(
            collection_name="documents",
            embedding_function=embeddings
        )
    
    def add_documents(self, docs: list, tenant_id: str):
        # Add tenant_id to metadata
        for doc in docs:
            doc.metadata["tenant_id"] = tenant_id
        
        self.vectorstore.add_documents(docs)
    
    def search(self, query: str, tenant_id: str, k: int = 5):
        # CRITICAL: Always filter by tenant_id
        return self.vectorstore.similarity_search(
            query,
            k=k,
            filter={"tenant_id": tenant_id}  # Ensures isolation
        )
```

---

## 3. Database Isolation Patterns

**Pattern 1: Shared Database**
```python
# All tenants in one DB, filtered by tenant_id
class TenantAwareRepository:
    def __init__(self, tenant_id: str):
        self.tenant_id = tenant_id
    
    def get_conversations(self):
        return db.query("""
            SELECT * FROM conversations 
            WHERE tenant_id = %s
        """, (self.tenant_id,))
```

**Pattern 2: Schema Per Tenant**
```python
# Each tenant gets own PostgreSQL schema
def get_tenant_session(tenant_id: str):
    engine = create_engine(DATABASE_URL)
    connection = engine.connect()
    
    # Set search path to tenant schema
    connection.execute(text(f"SET search_path TO tenant_{tenant_id}"))
    
    return Session(bind=connection)
```

**Pattern 3: Database Per Tenant**
```python
# Separate database for each tenant
class TenantDatabaseRouter:
    def __init__(self):
        self.connections = {}
    
    def get_connection(self, tenant_id: str):
        if tenant_id not in self.connections:
            self.connections[tenant_id] = create_engine(
                f"postgresql://server/tenant_{tenant_id}_db"
            )
        return self.connections[tenant_id]
```

---

## 4. Enforcing Security Boundaries

```python
from functools import wraps
from flask import request, abort

def require_tenant(f):
    """Decorator to enforce tenant context."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Extract tenant from JWT or API key
        tenant_id = get_tenant_from_request(request)
        
        if not tenant_id:
            abort(401, "No tenant context")
        
        # Inject tenant into function
        return f(tenant_id=tenant_id, *args, **kwargs)
    
    return decorated_function

@app.post("/documents")
@require_tenant
def add_document(tenant_id: str, document: dict):
    # tenant_id automatically provided and enforced
    vector_store.add_documents([document], tenant_id=tenant_id)
```

---

## 5. Compliance Considerations

```python
class TenantConfig:
    """Per-tenant compliance settings."""
    def __init__(self, tenant_id: str):
        self.tenant_id = tenant_id
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        return {
            "data_residency": "EU",  # GDPR
            "retention_days": 90,
            "encryption_at_rest": True,
            "pii_handling": "mask",
            "audit_level": "full"
        }
    
    def can_store_in_region(self, region: str) -> bool:
        return region == self.config["data_residency"]
```

---

## Quick Reference

| Aspect | Implementation |
|--------|----------------|
| **Vector Store** | Filter by tenant_id in metadata |
| **Database** | Schema per tenant or filter rows |
| **API** | Decorator enforces tenant context |
| **Compliance** | Per-tenant configuration |
